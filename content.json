[{"title":"程序员","date":"2017-03-18T15:05:14.000Z","path":"2017/03/18/Programmer/","text":"从最早接触C言语，再到C++，perl，到现在的java，涉及软件世界也有些许年了，编程一直是自己很喜欢的事。工作快两年了,怎样成为程序员,一直在不断地思考、探索？因为在自己心中，程序员职业一直是充满艺术性的，程序员是艺术家（艺术家：具有较高的审美能力和娴熟的创造技巧并从事艺术创作劳动而有一定成就的艺术工作者），是一个源于自然，发于心灵的艺术作品创作者。这世界，程序员太少，码农太多，自己现在也是一个活生生的码农。不知是哪个聪明的人发明的这么恰当的词汇“码农”。不过，很多时候一周能搬几行代码，砌个功能也是一种奢望，因为总有一堆公司琐事在困扰的你。 今天网上看到一篇老外写的文章关于怎样成为程序员，对自己很有指导意义，总结起来分下面5点：1.问题分解： 编程是解决问题，在你开始写任何代码之前，你应该有一套清晰的解决问题的方法论。程序员，能够将问题不断分解为更小部分，直到这些部分可以解决。同时会选出最合适的一种方法，方便实现，方便测试。2.方案分析： 程序员应该具备考虑多种场景的能力。在不同的场景下，结果很有可能南辕北辙。例如：如果参数时null，会发生什么；如这些条件都为true，又会怎样；该方法是否同步，并发场景下又改怎么处理。换句话说，程序员也是测试人员。相反的，码农很有可能考虑的只有一种发生的场景，对不其他场景触发的错误就没有不知道如何去cover。3.命名： 在程序设计中会涉及到大量的命名：类，方法，变量。程序设计的代码其实就是一份文档，通过名字就能大体清楚代码的功能。其实，能合适的命名是困难的，因为需要你清楚的知道每个名字代表的含义。4.连贯性： 连贯性是一个重要的性质。涉及各种变量命名，方法名，模块的分解，目录结构，错误处理，日志记录，文档等等。例如：一些相关变量一起出现在用到它们的时候，当有一个丢失的时候，能帮助你更快的发现。5.学习 作为程序员，你需要不断地学习。在增加一个新的特征的时候，你需要明白背后含义。当增加一段代码到程序中，应该知道放何处，怎么放是合适的。同时深入理解开发的程序，能够正确的处理。当你有较强的学习能力的时候，将会成为有效的开发者。程序的世界知识，框架，技术更新很快，信息量又巨大。你应该具有辨别什么是好的，什么是不好的能力。 路漫漫其修远兮 吾将上下而求索 愿自己早日成为程序员。","tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://mcgwinds.github.io/tags/杂谈/"}]},{"title":"dubbo(2)->ExtensionLoader","date":"2017-03-15T13:12:18.000Z","path":"2017/03/15/ExtensionLoader/","text":"前一篇文章总结了一下JDK的SPI机制，dubbo基于基础上扩展了一套自己的扩展机制，通过ExtensionLoader类实现。第一次看ExtensionLoader源码，一脸懵逼，debug几次还是云里雾里。后来通过网上查资料，看到了Cooma（https://github.com/alibaba/cooma/wiki），而Cooma的来源就是dubbo项目中的SPI。Cooma是一个独立的Java微容器，所以打算先从它讲起，后面的文章再分析dubbo框架中是如何运用ExtensionLoader的。 Comma，官方介绍的已经非常详细了，这里大体说一下几个特点： 1）以插件方式加载扩展（SPI） 2）支持依赖扩展点的自动加载（IOC） 3 可以有扩展点Wrapper，为扩展写公共Filter代码（AOP） 下面通过showcase来分析Comma源码了解这几大特点，Comma的代码主要两个类Extension(把一个接口标识成扩展点)，ExtensionLoader(加载和管理扩展)。 //showcase: //扩展接口 package com.alibaba.demo.cooma.car; import com.alibaba.cooma.Extension; @Extension(&quot;sport&quot;) public interface Car { void run(); }","tags":[{"name":"Comma","slug":"Comma","permalink":"https://mcgwinds.github.io/tags/Comma/"}]},{"title":"RPC框架","date":"2017-03-12T12:39:14.000Z","path":"2017/03/12/rpc/","text":"分布式服务框架：用于实现服务复用，由一个RPC框架，注册中心，监控中心组成。大体会部署在应用层和数据层之间。其中RPC框架是最重要的部分，由服务端和客户端两部分组成，服务端暴露服务，会将服务信息注册到注册中心，客户端调用服务，会从注册中心获取服务信息，然后与服务端进行交互。实现一个高并发、高可用、高性能的的RPC框架涉及很多技术点。 下面是一个简单的RPC框架showcase，没有涉及注册中心，监控中心，服务端启动通过export方法暴露服务，客户端启动通过refer方法引用服务。 //暴露服务： package com.mcg.rpc.server; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Method; import java.net.ServerSocket; import java.net.Socket; public class Provider { public static void export(final Object instance, int port) throws Exception { if(instance==null) throw new IllegalArgumentException(&quot;service is null&quot;); if (port &gt; 65535) throw new IllegalArgumentException(port + &quot;is invalid&quot;); ServerSocket serverSocket = new ServerSocket(port); for(;;) { try { final Socket socket = serverSocket.accept(); new Thread(new Runnable() { public void run() { try { try { ObjectInputStream objectInputStream = new ObjectInputStream(socket.getInputStream()); try { String methodName = objectInputStream.readUTF(); Class&lt;?&gt;[] parameterTypes = (Class&lt;?&gt;[])objectInputStream.readObject(); Object[] arguments = (Object[])objectInputStream.readObject(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(socket.getOutputStream()); try { Method method = instance.getClass().getMethod(methodName, parameterTypes); Object result = method.invoke(instance, arguments); objectOutputStream.writeObject(result); } catch (Throwable t) { objectOutputStream.writeObject(t); } finally { objectOutputStream.close(); } } finally { objectInputStream.close(); } } finally { socket.close(); } } catch (Exception e) { e.printStackTrace(); } } }).start(); } catch (Exception e) { e.printStackTrace(); } } } } //引用服务： package com.mcg.rpc.client; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; import java.net.Socket; public class Consumer { @SuppressWarnings(&quot;unchecked&quot;) public static &lt;T&gt; T refer(final Class&lt;T&gt; serviceInterface,final String host,final int port) { return (T)Proxy.newProxyInstance(serviceInterface.getClassLoader(),new Class&lt;?&gt;[]{serviceInterface}, new InvocationHandler() { public Object invoke(Object proxy, Method method, Object[] arguments) throws Throwable { Socket socket = new Socket(host, port); try { ObjectOutputStream output = new ObjectOutputStream(socket.getOutputStream()); try { output.writeUTF(method.getName()); output.writeObject(method.getParameterTypes()); output.writeObject(arguments); ObjectInputStream input = new ObjectInputStream(socket.getInputStream()); try { Object result = input.readObject(); if (result instanceof Throwable) { throw (Throwable) result; } return result; } finally { input.close(); } } finally { output.close(); } } finally { socket.close(); } } }); } } //服务接口： package com.mcg.rpc.service; public interface HelloService { void say(String name); } //服务实现： package com.mcg.rpc.service; public class HelloServiceImpl implements HelloService { public void say(String name) { System.out.println(&quot;hello:&quot; + name); } } //测试: package com.mcg.rpc.server; import com.mcg.rpc.service.HelloService; import com.mcg.rpc.service.HelloServiceImpl; public class ServerTest { private final static int PORT=1234; public static void main(String args []) throws Exception { HelloService instance=new HelloServiceImpl(); Provider.export(instance, PORT); } } package com.mcg.rpc.client; import com.mcg.rpc.service.HelloService; public class ClientTest { private final static int PORT=1234; private final static String HOST=&quot;127.0.0.1&quot;; public static void main(String args []) { HelloService helloService=Consumer.refer(HelloService.class, HOST, PORT); helloService.say(&quot;mcg&quot;); } } //结果： hello:mcg","tags":[{"name":"RPC","slug":"RPC","permalink":"https://mcgwinds.github.io/tags/RPC/"}]},{"title":"dubbo(1)->Serviceloader","date":"2017-03-12T12:39:14.000Z","path":"2017/03/12/serviceloader/","text":"中间件技术一直都是自己最感兴趣，有分布式服务框架，分布式消息队列，分布式缓存，分布式数据服务等等，参与开发其中任一一个项目都会学到很多知识，很幸运在开始参加工作后的第一个项目就是分布式服务框架，后来接触到了dubbo，被dubbo的设计所吸引，虽然有时间偶尔也会看看dubbo的代码，但没有系统的好好总结沉淀下来，看得如同过往云烟，时间也就那样的流逝了。最近也不断地在反思，工作快2两年了，像是一直在原地踏步，很多时候都是急于求成，自知其然，却不知其所以然，看着距离自己的第一个目标还那么的远，所以决定好好的静下心来先从学dubbo开始。 dubbo是服务框架，服务框架是用于实现服务的复用的框架，是软件框架。那框架是什么？让我联想到了建筑框架，建筑框架确定了整个建筑的结构，建筑框架允许你在不改变结构的基础上，自由改变其内容。例如，你可以用墙体随意分隔房间。所以框架就好比建筑框架，可以这样说，框架的本质就是“扩展”。在一个框架中，实现丰富的功能固然重要，然而更重要的是：建立良好的扩展机制。 dubbo基于JDK中的SPI机制扩展了一套自己的扩展机制，让使用者方便地自己扩展和实现自己的插件。下面介绍JDK提供的SPI机制(java.util.ServiceLoader)： SPI英文为Service Provider Interface单从字面可以理解为Service提供者接口，正如从SPI的名字去理解SPI就是Service提供者接口；提供给服务提供厂商与扩展框架功能的开发者使用的接口。 SPI 机制的约定： 1) 在META-INF/services/目录中创建以接口全限定名命名的文件该文件内容为Api具体实现类的全限定名 2) 使用ServiceLoader类动态加载META-INF中的实现类 3) 如SPI的实现类为Jar则需要放在主程序classPath中 4) Api具体实现类必须有一个不带参数的构造方法 下面是基于JDK的SPI的showcase //工具类(对接用户和SPI)： package com.mcg.java.tool.serviceloader.utils; import java.util.ServiceLoader; import java.util.concurrent.ConcurrentHashMap; import java.util.concurrent.ConcurrentMap; //工具类 public class ServicerLoaderUtils { //保存spi加载的服务 private static ConcurrentMap&lt;String,Object&gt; services=new ConcurrentHashMap&lt;String,Object&gt;(); //用户调用方法,获取相应的服务 public static Object getService(String name,Class&lt;?&gt; clazz) throws Exception { Object service= services.get(name); if(null==service) { load(clazz); service= services.get(name); } return service; } //加载服务 public static &lt;T&gt; void load(Class&lt;T&gt; service) throws Exception { for (T t:ServiceLoader.load(service)) { String name=t.getClass().getAnnotation(ServiceAnnotation.class).name(); services.putIfAbsent(name, t); } } } //注解工具类： package com.mcg.java.tool.serviceloader.utils; import java.lang.annotation.Documented; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Documented @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) public @interface ServiceAnnotation { String name() default &quot;default&quot;; } //服务接口： package com.mcg.java.tool.serviceloader; public interface Handler { void handler(); } //服务实现： package com.mcg.java.tool.serviceloader.HandlerImpl; import com.mcg.java.tool.serviceloader.Handler; import com.mcg.java.tool.serviceloader.utils.ServiceAnnotation; @ServiceAnnotation public class DefaultHandlerImpl implements Handler { public void handler() { System.out.println(&quot;this is defaultHandler&quot;); } } package com.mcg.java.tool.serviceloader.HandlerImpl; import com.mcg.java.tool.serviceloader.Handler; import com.mcg.java.tool.serviceloader.utils.ServiceAnnotation; @ServiceAnnotation(name=&quot;handlerImpl1&quot;) public class HandlerImpl1 implements Handler { public void handler() { System.out.println(&quot;this is handlerImpl1&quot;); } } package com.mcg.java.tool.serviceloader.HandlerImpl; import com.mcg.java.tool.serviceloader.Handler; import com.mcg.java.tool.serviceloader.utils.ServiceAnnotation; @ServiceAnnotation(name=&quot;handlerImpl2&quot;) public class HandlerImpl2 implements Handler { public void handler() { System.out.println(&quot;this is handlerImpl2&quot;); } } //SPI配置文件（META-INF/services/com.mcg.java.tool.serviceloader.Handler） com.mcg.java.tool.serviceloader.HandlerImpl.DefaultHandlerImpl com.mcg.java.tool.serviceloader.HandlerImpl.HandlerImpl1 com.mcg.java.tool.serviceloader.HandlerImpl.HandlerImpl2 //测试: package com.mcg.java.tool.serviceloader; import com.mcg.java.tool.serviceloader.utils.ServicerLoaderUtils; public class ServiceloaderTest { @SuppressWarnings(&quot;unchecked&quot;) public static void main(String[] args) throws Exception { Handler handler=(Handler) ServicerLoaderUtils.getService(&quot;default&quot;,Handler.class); handler.handler(); Handler handler1=(Handler) ServicerLoaderUtils.getService(&quot;handlerImpl1&quot;,Handler.class); handler1.handler(); Handler handler2=(Handler) ServicerLoaderUtils.getService(&quot;handlerImpl2&quot;,Handler.class); handler2.handler(); } } //结果： this is defaultHandler this is handlerImpl1 this is handlerImpl2 在上面的showcase中，ServicerLoaderUtils和ServiceAnnotation是两个工具类，只要基于这两个工具类就可以实现基于名字来获取不同的服务，然后基于策略模式执行相应的服务。ServicerLoaderUtils的load方法中对接ServiceLoader来实现服务的加载。 ServiceLoader的源码分析 上面showcase中先根据ServiceLoader的load静态方法根据目标接口加载出一个ServiceLoader实例，然后可以遍历这个实例（实现了Iterable接口），获取到接口的所有实现类。 ServiceLoader有几个重要属性： //查找实现类的前级目录 private static final String PREFIX = &quot;META-INF/services/&quot;; //要加载的接口 private Class&lt;S&gt; service; // private ClassLoader loader; // 缓存已经加载过的实现类，其中key为实现类的全名 private LinkedHashMap&lt;String,S&gt; providers = new LinkedHashMap&lt;&gt;(); //延迟加载器 private LazyIterator lookupIterator; 在上面调用load方法中，会创建ServiceLoader实例，会初始化的重要属性，此时还没有进行任何接口实现类的加载操作，属于延迟加载类型的。 在执行for循环的时候，由于ServiceLoader实现了Iterable接口，即实现了该接口的iterator()方法，实现内容如下： public Iterator&lt;S&gt; iterator() { return new Iterator&lt;S&gt;() { Iterator&lt;Map.Entry&lt;String,S&gt;&gt; knownProviders = providers.entrySet().iterator(); public boolean hasNext() { if (knownProviders.hasNext()) return true; return lookupIterator.hasNext(); } public S next() { if (knownProviders.hasNext()) return knownProviders.next().getValue(); return lookupIterator.next(); } public void remove() { throw new UnsupportedOperationException(); } }; } 其实for循环就是调用上述hasNext()和next()方法的过程。 第一次循环遍历会使用lookupIterator去查找，之后就缓存到providers中。LazyIterator会去加载类路径下/META-INF/services/接口全称 文件的url地址，使用如下代码来加载： String fullName = PREFIX + service.getName(); if (loader == null) configs = ClassLoader.getSystemResources(fullName); else configs = loader.getResources(fullName); 文件加载并解析完成之后，得到一系列的接口实现类的完整类名，调用next()方法时才回去真正执行接口实现类的加载操作，并根据无参构造器创建出一个实例，存到providers中； 之后再次遍历ServiceLoader，就直接遍历providers中的数据 S p = service.cast(c.newInstance()); providers.put(cn, p); ServiceLoader缺点分析 虽然ServiceLoader也算是使用的延迟加载，但是基本只能通过遍历全部获取，也就是接口的实现类全部加载并实例化一遍。如果你并不想用某些实现类，它也被加载并实例化了，这就造成了浪费。 获取某个实现类的方式不够灵活，只能通过Iterator形式获取，不能根据某个参数来获取对应的实现类","tags":[{"name":"SPI","slug":"SPI","permalink":"https://mcgwinds.github.io/tags/SPI/"}]},{"title":"Byte","date":"2017-01-13T13:00:34.000Z","path":"2017/01/13/Byte/","text":"Byte类是基本类型byte的包装类。 类定义: public final class Byte extends Number implements Comparable&lt;Byte&gt; 属性: 私有属性: private final byte value;（value属性就是Byte对象中真正保存int值的） 公共属性: public static final byte MIN_VALUE = -128; public static final byte MAX_VALUE = 127; public static final Class&lt;Byte&gt; TYPE = Class.getPrimitiveClass(&quot;byte&quot;); public static final int SIZE = 8; 方法: Integer提供了两个构造方法： //构造一个新分配的 Byte 对象，它表示指定的 byte 值。 public Byte(byte arg0) { this.value = arg0; } //构造一个新分配的 Byte 对象，它表示 String 参数所指示的 byte 值。 public Byte(String arg0) throws NumberFormatException { this.value = parseByte(arg0, 10); } Byte valueOf(byte arg)方法（effective java第一条准则）: //valueOf方法源码 public static Byte valueOf(byte arg) { return Byte.ByteCache.cache[arg + 128]; } Byte类和Integer一样，调用valueOf方法时，会从缓存中取，不过不同的是Byte类调用valueOf取得都是缓存ByteCache中的值。 private static class ByteCache { static final Byte[] cache = new Byte[256]; static { for (int arg = 0; arg &lt; cache.length; ++arg) { cache[arg] = new Byte((byte) (arg - 128)); } } } 作为Byte类的静态内部类，和Byte类一起加载，加载过程中会创建一个长度为256的数组，同时在静态内部块中初始化。 String转成Byte（byte）的方法: Byte decode(String arg) Byte valueOf(String arg, int arg0) byte parseByte(String arg) byte parseByte(String arg, int arg0) 上述方法都是直接或间接的先将String转化为int类型，例如parseByte(String arg, int arg0)方法首先将String转化为int，然后判断该值是否在[-128，127]之间。 public static byte parseByte(String arg, int arg0) throws NumberFormatException { int arg1 = Integer.parseInt(arg, arg0); if (arg1 &gt;= -128 &amp;&amp; arg1 &lt;= 127) { return (byte) arg1; } else { throw new NumberFormatException(&quot;Value out of range. Value:\\&quot;&quot; + arg + &quot;\\&quot; Radix:&quot; + arg0); } } int转成String的方法: String toString(byte arg) Byte的toString(byte arg)方法调用的是Integer的toString(byte arg，10)方法。 compareTo方法: Byte类实现了Comparable接口，所以Byte对象可以和另外一个Byte对象进行比较。 public int compareTo(Byte arg0) { return compare(this.value, arg0.value); } public static int compare(byte arg, byte arg0) { return arg - arg0; } 代码实现比较简单，就是拿出其中的byte类型的value进行比较。","tags":[{"name":"JAVA基础","slug":"JAVA基础","permalink":"https://mcgwinds.github.io/tags/JAVA基础/"}]},{"title":"Boolean","date":"2017-01-12T13:29:34.000Z","path":"2017/01/12/Boolean/","text":"Boolean类是基本类型boolean的包装类。 类定义: public final class Boolean implements Serializable, Comparable&lt;Boolean&gt; 类的定义与Integer类似，这里就不累赘了。 属性: 私有属性: private final boolean value;（value属性就是Boolean对象中真正保存boolean值的） 当我们使用new Boolean(True)创建一个Boolean对象的时候，就会用以下形式给value赋值 public Boolean(boolean arg0) { this.value = arg0; } 公共属性: //ture对应的Boolean静态常量。 public static final Boolean TRUE = new Boolean(true); //false对应的Boolean静态常量 public static final Boolean FALSE = new Boolean(false); public static final Class&lt;Boolean&gt; TYPE = Class .getPrimitiveClass(&quot;boolean&quot;); 方法: Boolean提供了两个构造方法： //构造一个新分配的 Boolean 对象，它表示指定的 boolean 值。 public Boolean(boolean arg0) { this.value = arg0; } //构造一个新分配的 Boolean 对象，它表示 String 参数所指示的 boolean 值。 public Boolean(String arg0) { this(toBoolean(arg0)); } Boolean valueOf(boolean i)方法: //valueOf方法源码 public static Boolean valueOf(boolean arg) { return arg ? TRUE : FALSE; } 当参数是true时取常量TRUE，当参数是false时取常量FALSE。 String转成Boolean的方法: boolean getBoolean(String arg) boolean toBoolean(String arg) parseBoolean(String arg) Boolean valueOf(String arg) getBoolean: public static boolean getBoolean(String arg) { boolean arg0 = false; try { arg0 = toBoolean(System.getProperty(arg)); } catch (IllegalArgumentException arg2) { ; } catch (NullPointerException arg3) { ; } return arg0; } 确定具有指定名称的系统属性的Boolean值。 toBoolean: private static boolean toBoolean(String arg) { return arg != null &amp;&amp; arg.equalsIgnoreCase(&quot;true&quot;); } 将参数与字符串true进行比较 parseBoolean: public static boolean parseBoolean(String arg) { return toBoolean(arg); } 该方法调用toBoolean，将String转化为boolean。 boolean转成String的方法: String toString(boolean arg) 直接看toString方法，toString方法的定义比较简单，就是把一个boolean类型转换成字符串类型。 public static String toString(boolean arg) { return arg ? &quot;true&quot; : &quot;false&quot;; } compareTo方法: public int compareTo(Boolean arg0) { return compare(this.value, arg0.value); } public static int compare(boolean arg, boolean arg0) { return arg == arg0 ? 0 : (arg ? 1 : -1); } 代码实现比较简单，就是拿出其中的boolean类型的value进行比较。","tags":[{"name":"JAVA基础","slug":"JAVA基础","permalink":"https://mcgwinds.github.io/tags/JAVA基础/"}]},{"title":"Integer","date":"2017-01-11T04:29:34.000Z","path":"2017/01/11/Integer/","text":"Integer类是基本类型int的包装类。 类定义: public final class Integer extends Number implements Comparable&lt;Integer&gt; 从类定义中我们可以知道以下几点： 1、Integer类不能被继承 2、Integer类实现了Comparable接口，所以可以用compareTo进行比较并且Integer对象只能和Integer类型的对象进行比较，不能和其他类型比较（至少调用compareTo方法无法比较）。 3、Integer继承了Number类，所以该类可以调用longValue、floatValue、doubleValue等系列方法返回对应的类型的值。 属性: 私有属性: private final int value;（value属性就是Integer对象中真正保存int值的） 当我们使用new Integer(10)创建一个Integer对象的时候，就会用以下形式给value赋值 public Integer(int value) { this.value = value; } 从value的定义形式中可以看出value被定义成final类型。也就说明，一旦一个Integer对象被初始化之后，就无法再改变value的值。 这里深入讨论一下以下代码的逻辑： public class IntegerTest { public static void main(String[] args) { Integer i = new Integer(10); i = 5; } } 在以上代码中，首先调用构造函数new一个Integer对象，给私有属性value赋值，这时value=10,接下来使用i=5的形式试图改变i的值。 有一点开发经验的同学都知道，这个时候如果使用变量i，那么它的值一定是5，那么i=5这个赋值操作到底做了什么呢？到底是如何改变i的值的呢？是改变了原有对象i中value的值还是重新创建了一个新的Integer对象呢？ 其实上面的代码编译阶段编译器就会把i=5转成i = Integer.valueOf(5)[包装操作];这里先直接给出结论，i=5操作并没有改变使用Integer i = new Integer(10);创建出来的i中的value属性的值。要么是直接返回一个已有对象，要么新建一个对象。这里的具体实现细节在后面讲解valueOf方法的时候给出。公共属性: //值为 （－（2的31次方）） 的常量，它表示 int 类型能够表示的最小值。 public static final int MIN_VALUE = 0x80000000; //值为 （（2的31次方）－1） 的常量，它表示 int 类型能够表示的最大值。 public static final int MAX_VALUE = 0x7fffffff; //表示基本类型 int 的 Class 实例。 public static final Class&lt;Integer&gt; TYPE = (Class&lt;Integer&gt;) Class.getPrimitiveClass(&quot;int&quot;); //用来以二进制补码形式表示 int 值的比特位数。 public static final int SIZE = 32; 方法: Integer提供了两个构造方法： //构造一个新分配的 Integer 对象，它表示指定的 int 值。 public Integer(int value) { this.value = value; } //构造一个新分配的 Integer 对象，它表示 String 参数所指示的 int 值。 public Integer(String s) throws NumberFormatException { this.value = parseInt(s, 10); } Integer valueOf(int i)方法（effective java第一条准则）: //valueOf方法源码 public static Integer valueOf(int i) { if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); } 我们看到了在valueOf方法中有一个if表达式，当i小于IntegerCache中high属性，大于IntegerCache中low属性时，返回IntegerCache中cache数组中与i相关的某个值，从名义上可以看出IntegerCache是Integer的缓存，那么IntegerCache又是怎样实现的呢？ private static class IntegerCache { static final int low = -128; static final int high; static final Integer[] cache; static { int arg = 127; String arg0 = VM .getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;); int arg1; if (arg0 != null) { arg1 = Integer.parseInt(arg0); arg1 = Math.max(arg1, 127); arg = Math.min(arg1, 2147483518); } high = arg; cache = new Integer[high - -128 + 1]; arg1 = -128; for (int arg2 = 0; arg2 &lt; cache.length; ++arg2) { cache[arg2] = new Integer(arg1++); } } } 以上是IntegerCache的源码，IntegerCache有三个属性：low=-128，high（通常=127），cache数组，一个静态代码块。IntegerCache的源码结构可知，当加载Integer类时，因为IntegerCache是静态内部类所以会被加载，同时会执行静态代码块，在静态代码块中给high赋值，同时创建cache数组并赋值，cache数组的长度为(high - low) + 1。 所以valueOf方法的if表达式其实取的是IntegerCache中cache数组的值，这么做的好处就是当i在[low high]范围内，就不用重复创建对象，直接从cache中取。 String转成Integer（int）的方法: Integer getInteger(String nm) Integer getInteger(String nm, int val) Integer getInteger(String nm, Integer val) Integer decode(String nm) Integer valueOf(String s) Integer valueOf(String s, int radix) int parseUnsignedInt(String s) int parseUnsignedInt(String s, int radix) int parseInt(String s) int parseInt(String s, int radix) 以上所有方法都能实现将String类型的值转成Integer(int)类型（如果 String 不包含可解析整数将抛出NumberFormatException） 可以说，所有将String转成Integer的方法都是基于parseInt方法实现的。简单看一下以上部分方法的调用栈。 getInteger(String nm) ---&gt; getInteger(nm, null);---&gt;Integer.decode()---&gt;Integer.valueOf()---&gt;parseInt() getInteger: 确定具有指定名称的系统属性的整数值。 第一个参数被视为系统属性的名称。通过 System.getProperty(java.lang.String) 方法可以访问系统属性。然后，将该属性的字符串值解释为一个整数值，并返回表示该值的 Integer 对象。使用 getProperty 的定义可以找到可能出现的数字格式的详细信息。其中参数nm应该在System的props中可以找到。 decode: public static Integer decode(String nm) throws NumberFormatException 该方法的作用是将 String 解码为 Integer。接受十进制、十六进制和八进制数字。 parseInt: public static int parseInt(String s) throws NumberFormatException { return parseInt(s,10); } public static int parseInt(String s, int radix) throws NumberFormatException 使用第二个参数指定的基数(如果没指定，则按照十进制处理），将字符串参数解析为有符号的整数。如果发生以下任意一种情况，则抛出一个 NumberFormatException 类型的异常： 1.第一个参数为 null 或一个长度为零的字符串。 2.基数小于 Character.MIN_RADIX 或者大于 Character.MAX_RADIX。 3.假如字符串的长度超过 1，那么除了第一个字符可以是减号 ‘-‘ (‘u002D’) 外，字符串中存在任意不是由指定基数的数字表示的字符. 4.字符串表示的值不是 int 类型的值。 总结: 上面列举了很多能够将String转成Integer的方法。那么他们之间有哪些区别，又该如何选择呢？ parseInt方法返回的是基本类型int 其他的方法返回的是Integer valueOf（String）方法会调用valueOf(int)方法。 如果只需要返回一个基本类型，而不需要一个对象，可以直接使用Integert.parseInt(“123”); 如果需要一个对象，那么建议使用valueOf(),因为该方法可以借助缓存带来的好处。 如果和进制有关，那么就是用decode方法。 如果是从系统配置中取值，那么就是用getInteger int转成String的方法: String toString() static String toString(int i) static String toString(int i, int radix) static String toBinaryString(int i) static String toHexString(int i) static String toOctalString(int i) static String toUnsignedString(int i) static String toUnsignedString(int i, int radix) 直接看toString方法，toString方法的定义比较简单，就是把一个int类型的数字转换成字符串类型，但是这个方法的实现调用了一系列方法。 public static String toString(int i) { if (i == Integer.MIN_VALUE) //下面代码要将负数转化为正数 return &quot;-2147483648&quot;; int size = (i &lt; 0) ? stringSize(-i) + 1 : stringSize(i); char[] buf = new char[size]; getChars(i, size, buf); return new String(buf, true); } compareTo方法: Integer类实现了Comparable接口，所以Integer对象可以和另外一个Integer对象进行比较。 public int compareTo(Integer anotherInteger) { return compare(this.value, anotherInteger.value); } public static int compare(int x, int y) { return (x &lt; y) ? -1 : ((x == y) ? 0 : 1); } 代码实现比较简单，就是拿出其中的int类型的value进行比较。 参考资料 http://www.hollischuang.com/archives/1058","tags":[{"name":"JAVA基础","slug":"JAVA基础","permalink":"https://mcgwinds.github.io/tags/JAVA基础/"}]}]