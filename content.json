[{"title":"程序员","date":"2017-03-18T15:05:14.000Z","path":"2017/03/18/Programmer/","text":"从最早接触C言语，再到C++，perl，到现在的java，涉及软件世界也有些许年了，编程一直是自己很喜欢的事。工作快两年了,怎样成为程序员,一直在不断地思考、探索？因为在自己心中，程序员职业一直是充满艺术性的，程序员是艺术家（艺术家：具有较高的审美能力和娴熟的创造技巧并从事艺术创作劳动而有一定成就的艺术工作者），是一个源于自然，发于心灵的艺术作品创作者。这世界，程序员太少，码农太多，自己现在也是一个活生生的码农。不知是哪个聪明的人发明的这么恰当的词汇“码农”。不过，很多时候一周能搬几行代码，砌个功能也是一种奢望，因为总有一堆公司琐事在困扰的你。 今天网上看到一篇老外写的文章关于怎样成为程序员，对自己很有指导意义，总结起来分下面5点：1.问题分解： 编程是解决问题，在你开始写任何代码之前，你应该有一套清晰的解决问题的方法论。程序员，能够将问题不断分解为更小部分，直到这些部分可以解决。同时会选出最合适的一种方法，方便实现，方便测试。2.方案分析： 程序员应该具备考虑多种场景的能力。在不同的场景下，结果很有可能南辕北辙。例如：如果参数时null，会发生什么；如这些条件都为true，又会怎样；该方法是否同步，并发场景下又改怎么处理。换句话说，程序员也是测试人员。相反的，码农很有可能考虑的只有一种发生的场景，对不其他场景触发的错误就没有不知道如何去cover。3.命名： 在程序设计中会涉及到大量的命名：类，方法，变量。程序设计的代码其实就是一份文档，通过名字就能大体清楚代码的功能。其实，能合适的命名是困难的，因为需要你清楚的知道每个名字代表的含义。4.连贯性： 连贯性是一个重要的性质。涉及各种变量命名，方法名，模块的分解，目录结构，错误处理，日志记录，文档等等。例如：一些相关变量一起出现在用到它们的时候，当有一个丢失的时候，能帮助你更快的发现。5.学习 作为程序员，你需要不断地学习。在增加一个新的特征的时候，你需要明白背后含义。当增加一段代码到程序中，应该知道放何处，怎么放是合适的。同时深入理解开发的程序，能够正确的处理。当你有较强的学习能力的时候，将会成为有效的开发者。程序的世界知识，框架，技术更新很快，信息量又巨大。你应该具有辨别什么是好的，什么是不好的能力。 路漫漫其修远兮 吾将上下而求索 愿自己早日成为程序员。","tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://mcgwinds.github.io/tags/杂谈/"}]},{"title":"dubbo(2)->ExtensionLoader","date":"2017-03-15T13:12:18.000Z","path":"2017/03/15/ExtensionLoader/","text":"前一篇文章总结了一下JDK的SPI机制，dubbo基于基础上扩展了一套自己的扩展机制，通过ExtensionLoader类实现。第一次看ExtensionLoader源码，一脸懵逼，debug几次还是云里雾里。后来通过网上查资料，看到了Cooma（https://github.com/alibaba/cooma/wiki），而Cooma的来源就是dubbo项目中的SPI。Cooma是一个独立的Java微容器，所以打算先从它讲起，后面的文章再分析dubbo框架中是如何运用ExtensionLoader的。 Comma，官方介绍的已经非常详细了，这里大体说一下几个特点： 1）以插件方式加载扩展（SPI） 2）支持依赖扩展点的自动加载（IOC） 3 可以有扩展点Wrapper，为扩展写公共Filter代码（AOP） 下面通过showcase来分析Comma源码了解这几大特点，Comma的代码主要两个类Extension(把一个接口标识成扩展点)，ExtensionLoader(加载和管理扩展)。 //showcase: //扩展接口 package com.alibaba.demo.cooma.car; import com.alibaba.cooma.Extension; @Extension(&quot;sport&quot;) public interface Car { void run(); }","tags":[{"name":"Comma","slug":"Comma","permalink":"https://mcgwinds.github.io/tags/Comma/"}]},{"title":"RPC框架","date":"2017-03-12T12:39:14.000Z","path":"2017/03/12/rpc/","text":"分布式服务框架：用于实现服务复用，由一个RPC框架，注册中心，监控中心组成。大体会部署在应用层和数据层之间。其中RPC框架是最重要的部分，由服务端和客户端两部分组成，服务端暴露服务，会将服务信息注册到注册中心，客户端调用服务，会从注册中心获取服务信息，然后与服务端进行交互。实现一个高并发、高可用、高性能的的RPC框架涉及很多技术点。 下面是一个简单的RPC框架showcase，没有涉及注册中心，监控中心，服务端启动通过export方法暴露服务，客户端启动通过refer方法引用服务。 //暴露服务： package com.mcg.rpc.server; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Method; import java.net.ServerSocket; import java.net.Socket; public class Provider { public static void export(final Object instance, int port) throws Exception { if(instance==null) throw new IllegalArgumentException(&quot;service is null&quot;); if (port &gt; 65535) throw new IllegalArgumentException(port + &quot;is invalid&quot;); ServerSocket serverSocket = new ServerSocket(port); for(;;) { try { final Socket socket = serverSocket.accept(); new Thread(new Runnable() { public void run() { try { try { ObjectInputStream objectInputStream = new ObjectInputStream(socket.getInputStream()); try { String methodName = objectInputStream.readUTF(); Class&lt;?&gt;[] parameterTypes = (Class&lt;?&gt;[])objectInputStream.readObject(); Object[] arguments = (Object[])objectInputStream.readObject(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(socket.getOutputStream()); try { Method method = instance.getClass().getMethod(methodName, parameterTypes); Object result = method.invoke(instance, arguments); objectOutputStream.writeObject(result); } catch (Throwable t) { objectOutputStream.writeObject(t); } finally { objectOutputStream.close(); } } finally { objectInputStream.close(); } } finally { socket.close(); } } catch (Exception e) { e.printStackTrace(); } } }).start(); } catch (Exception e) { e.printStackTrace(); } } } } //引用服务： package com.mcg.rpc.client; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; import java.net.Socket; public class Consumer { @SuppressWarnings(&quot;unchecked&quot;) public static &lt;T&gt; T refer(final Class&lt;T&gt; serviceInterface,final String host,final int port) { return (T)Proxy.newProxyInstance(serviceInterface.getClassLoader(),new Class&lt;?&gt;[]{serviceInterface}, new InvocationHandler() { public Object invoke(Object proxy, Method method, Object[] arguments) throws Throwable { Socket socket = new Socket(host, port); try { ObjectOutputStream output = new ObjectOutputStream(socket.getOutputStream()); try { output.writeUTF(method.getName()); output.writeObject(method.getParameterTypes()); output.writeObject(arguments); ObjectInputStream input = new ObjectInputStream(socket.getInputStream()); try { Object result = input.readObject(); if (result instanceof Throwable) { throw (Throwable) result; } return result; } finally { input.close(); } } finally { output.close(); } } finally { socket.close(); } } }); } } //服务接口： package com.mcg.rpc.service; public interface HelloService { void say(String name); } //服务实现： package com.mcg.rpc.service; public class HelloServiceImpl implements HelloService { public void say(String name) { System.out.println(&quot;hello:&quot; + name); } } //测试: package com.mcg.rpc.server; import com.mcg.rpc.service.HelloService; import com.mcg.rpc.service.HelloServiceImpl; public class ServerTest { private final static int PORT=1234; public static void main(String args []) throws Exception { HelloService instance=new HelloServiceImpl(); Provider.export(instance, PORT); } } package com.mcg.rpc.client; import com.mcg.rpc.service.HelloService; public class ClientTest { private final static int PORT=1234; private final static String HOST=&quot;127.0.0.1&quot;; public static void main(String args []) { HelloService helloService=Consumer.refer(HelloService.class, HOST, PORT); helloService.say(&quot;mcg&quot;); } } //结果： hello:mcg","tags":[{"name":"RPC","slug":"RPC","permalink":"https://mcgwinds.github.io/tags/RPC/"}]},{"title":"dubbo(1)->Serviceloader","date":"2017-03-12T12:39:14.000Z","path":"2017/03/12/serviceloader/","text":"中间件技术一直都是自己最感兴趣，有分布式服务框架，分布式消息队列，分布式缓存，分布式数据服务等等，参与开发其中任一一个项目都会学到很多知识，很幸运在开始参加工作后的第一个项目就是分布式服务框架，后来接触到了dubbo，被dubbo的设计所吸引，虽然有时间偶尔也会看看dubbo的代码，但没有系统的好好总结沉淀下来，看得如同过往云烟，时间也就那样的流逝了。最近也不断地在反思，工作快2两年了，像是一直在原地踏步，很多时候都是急于求成，自知其然，却不知其所以然，看着距离自己的第一个目标还那么的远，所以决定好好的静下心来先从学dubbo开始。 dubbo是服务框架，服务框架是用于实现服务的复用的框架，是软件框架。那框架是什么？让我联想到了建筑框架，建筑框架确定了整个建筑的结构，建筑框架允许你在不改变结构的基础上，自由改变其内容。例如，你可以用墙体随意分隔房间。所以框架就好比建筑框架，可以这样说，框架的本质就是“扩展”。在一个框架中，实现丰富的功能固然重要，然而更重要的是：建立良好的扩展机制。 dubbo基于JDK中的SPI机制扩展了一套自己的扩展机制，让使用者方便地自己扩展和实现自己的插件。下面介绍JDK提供的SPI机制(java.util.ServiceLoader)： SPI英文为Service Provider Interface单从字面可以理解为Service提供者接口，正如从SPI的名字去理解SPI就是Service提供者接口；提供给服务提供厂商与扩展框架功能的开发者使用的接口。 SPI 机制的约定： 1) 在META-INF/services/目录中创建以接口全限定名命名的文件该文件内容为Api具体实现类的全限定名 2) 使用ServiceLoader类动态加载META-INF中的实现类 3) 如SPI的实现类为Jar则需要放在主程序classPath中 4) Api具体实现类必须有一个不带参数的构造方法 下面是基于JDK的SPI的showcase //工具类(对接用户和SPI)： package com.mcg.java.tool.serviceloader.utils; import java.util.ServiceLoader; import java.util.concurrent.ConcurrentHashMap; import java.util.concurrent.ConcurrentMap; //工具类 public class ServicerLoaderUtils { //保存spi加载的服务 private static ConcurrentMap&lt;String,Object&gt; services=new ConcurrentHashMap&lt;String,Object&gt;(); //用户调用方法,获取相应的服务 public static Object getService(String name,Class&lt;?&gt; clazz) throws Exception { Object service= services.get(name); if(null==service) { load(clazz); service= services.get(name); } return service; } //加载服务 public static &lt;T&gt; void load(Class&lt;T&gt; service) throws Exception { for (T t:ServiceLoader.load(service)) { String name=t.getClass().getAnnotation(ServiceAnnotation.class).name(); services.putIfAbsent(name, t); } } } //注解工具类： package com.mcg.java.tool.serviceloader.utils; import java.lang.annotation.Documented; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Documented @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) public @interface ServiceAnnotation { String name() default &quot;default&quot;; } //服务接口： package com.mcg.java.tool.serviceloader; public interface Handler { void handler(); } //服务实现： package com.mcg.java.tool.serviceloader.HandlerImpl; import com.mcg.java.tool.serviceloader.Handler; import com.mcg.java.tool.serviceloader.utils.ServiceAnnotation; @ServiceAnnotation public class DefaultHandlerImpl implements Handler { public void handler() { System.out.println(&quot;this is defaultHandler&quot;); } } package com.mcg.java.tool.serviceloader.HandlerImpl; import com.mcg.java.tool.serviceloader.Handler; import com.mcg.java.tool.serviceloader.utils.ServiceAnnotation; @ServiceAnnotation(name=&quot;handlerImpl1&quot;) public class HandlerImpl1 implements Handler { public void handler() { System.out.println(&quot;this is handlerImpl1&quot;); } } package com.mcg.java.tool.serviceloader.HandlerImpl; import com.mcg.java.tool.serviceloader.Handler; import com.mcg.java.tool.serviceloader.utils.ServiceAnnotation; @ServiceAnnotation(name=&quot;handlerImpl2&quot;) public class HandlerImpl2 implements Handler { public void handler() { System.out.println(&quot;this is handlerImpl2&quot;); } } //SPI配置文件（META-INF/services/com.mcg.java.tool.serviceloader.Handler） com.mcg.java.tool.serviceloader.HandlerImpl.DefaultHandlerImpl com.mcg.java.tool.serviceloader.HandlerImpl.HandlerImpl1 com.mcg.java.tool.serviceloader.HandlerImpl.HandlerImpl2 //测试: package com.mcg.java.tool.serviceloader; import com.mcg.java.tool.serviceloader.utils.ServicerLoaderUtils; public class ServiceloaderTest { @SuppressWarnings(&quot;unchecked&quot;) public static void main(String[] args) throws Exception { Handler handler=(Handler) ServicerLoaderUtils.getService(&quot;default&quot;,Handler.class); handler.handler(); Handler handler1=(Handler) ServicerLoaderUtils.getService(&quot;handlerImpl1&quot;,Handler.class); handler1.handler(); Handler handler2=(Handler) ServicerLoaderUtils.getService(&quot;handlerImpl2&quot;,Handler.class); handler2.handler(); } } //结果： this is defaultHandler this is handlerImpl1 this is handlerImpl2 在上面的showcase中，ServicerLoaderUtils和ServiceAnnotation是两个工具类，只要基于这两个工具类就可以实现基于名字来获取不同的服务，然后基于策略模式执行相应的服务。ServicerLoaderUtils的load方法中对接ServiceLoader来实现服务的加载。 ServiceLoader的源码分析 上面showcase中先根据ServiceLoader的load静态方法根据目标接口加载出一个ServiceLoader实例，然后可以遍历这个实例（实现了Iterable接口），获取到接口的所有实现类。 ServiceLoader有几个重要属性： //查找实现类的前级目录 private static final String PREFIX = &quot;META-INF/services/&quot;; //要加载的接口 private Class&lt;S&gt; service; // private ClassLoader loader; // 缓存已经加载过的实现类，其中key为实现类的全名 private LinkedHashMap&lt;String,S&gt; providers = new LinkedHashMap&lt;&gt;(); //延迟加载器 private LazyIterator lookupIterator; 在上面调用load方法中，会创建ServiceLoader实例，会初始化的重要属性，此时还没有进行任何接口实现类的加载操作，属于延迟加载类型的。 在执行for循环的时候，由于ServiceLoader实现了Iterable接口，即实现了该接口的iterator()方法，实现内容如下： public Iterator&lt;S&gt; iterator() { return new Iterator&lt;S&gt;() { Iterator&lt;Map.Entry&lt;String,S&gt;&gt; knownProviders = providers.entrySet().iterator(); public boolean hasNext() { if (knownProviders.hasNext()) return true; return lookupIterator.hasNext(); } public S next() { if (knownProviders.hasNext()) return knownProviders.next().getValue(); return lookupIterator.next(); } public void remove() { throw new UnsupportedOperationException(); } }; } 其实for循环就是调用上述hasNext()和next()方法的过程。 第一次循环遍历会使用lookupIterator去查找，之后就缓存到providers中。LazyIterator会去加载类路径下/META-INF/services/接口全称 文件的url地址，使用如下代码来加载： String fullName = PREFIX + service.getName(); if (loader == null) configs = ClassLoader.getSystemResources(fullName); else configs = loader.getResources(fullName); 文件加载并解析完成之后，得到一系列的接口实现类的完整类名，调用next()方法时才回去真正执行接口实现类的加载操作，并根据无参构造器创建出一个实例，存到providers中； 之后再次遍历ServiceLoader，就直接遍历providers中的数据 S p = service.cast(c.newInstance()); providers.put(cn, p); ServiceLoader缺点分析 虽然ServiceLoader也算是使用的延迟加载，但是基本只能通过遍历全部获取，也就是接口的实现类全部加载并实例化一遍。如果你并不想用某些实现类，它也被加载并实例化了，这就造成了浪费。 获取某个实现类的方式不够灵活，只能通过Iterator形式获取，不能根据某个参数来获取对应的实现类","tags":[{"name":"SPI","slug":"SPI","permalink":"https://mcgwinds.github.io/tags/SPI/"}]},{"title":"Enum","date":"2017-02-12T11:15:37.000Z","path":"2017/02/12/Enum/","text":"Java的枚举定义通过关键字Enum表示。Enum定义类似如下： package com.mcg.demo; public enum EnumDemo { Demo1(&quot;demo1&quot;),Demo2(&quot;demo2&quot;),Demo3(&quot;demo3&quot;); private String name; EnumDemo(String name) { this.name=name; } } 当我们使用EnumDemo类时，发现EnumDemo类默认给我们提供了values、valueOf方法 EnumDemo.values(); EnumDemo.valueOf(&quot;demo1&quot;); EnumDemo.valueOf(EnumDemo.class, &quot;demo1&quot;); 所以应该是编译器在编译源代码的时候，进行了特殊处理。需要分析编译后产生的class文件， public final class com.mcg.demo.EnumDemo extends java.lang.Enum&lt;com.mcg.demo.EnumDemo&gt; { public static final com.mcg.demo.EnumDemo Demo1; public static final com.mcg.demo.EnumDemo Demo2; public static final com.mcg.demo.EnumDemo Demo3; static {Demo1 = new com.mcg.demo.EnumDemo(&quot;Demo1&quot;,0); Demo2 = new com.mcg.demo.EnumDemo(&quot;Demo2&quot;,1); Demo3 = new com.mcg.demo.EnumDemo(&quot;Demo3&quot;,2); $VALUES = (new com.mcg.demo.EnumDemo[] { Demo1, Demo2, Demo3 });} private static final com.mcg.demo.EnumDemo $VALUES[]; private com.mcg.demo.EnumDemo(String s,int i) { super(s, i);} public static com.mcg.demo.EnumDemo[] values() { return (com.mcg.demo.EnumDemo[])$VALUES.clone(); } public static com.mcg.demo.EnumDemo valueOf(String name){ ... } } 短短的几行代码，被编译器处理过之后竟然变得这么多，看来，enmu关键字是java提供给我们的一个语法糖，我们发现，编译器帮我们在编译后默认继承java.lang.Enum类，而不像其他的类一样默认继承Object类。且采用enum声明后，该类会被编译器加上final声明，故该类是无法继承的。Enum是java.lang包中的一个类，Enum类在JDK中是这样描述：(This is the common base class of all Java language enumeration types)Java语言中所有枚举类型的公共基类。 public abstract class Enum&lt;E extends Enum&lt;E&gt;&gt; implements Comparable&lt;E&gt;, Serializable Enum类是一个抽象类，Enum实现了Serializable接口，可以序列化。 Enum实现了Comparable接口，可以进行比较，默认情况下，只有同类型的enum才进行比较（原因见后文），要实现不同类型的enum之间的比较，只能复写compareTo方法。 构造函数Enum是一个抽象类，不能被实例化，但是他有构造函数，从前面我们反编译出来的代码中，我们也发现了Enum的构造函数，在Enum中只有一个保护类型的构造函数： rotected Enum(String name, int ordinal) { this.name = name; this.ordinal = ordinal;//代表顺序，从0开始； } 其他方法 public String toString() { return name; } public final boolean equals(Object other) { return this==other; } public final int hashCode() { return super.hashCode(); } public final int compareTo(E o) { Enum other = (Enum)o; Enum self = this; if (self.getClass() != other.getClass() &amp;&amp; // optimization self.getDeclaringClass() != other.getDeclaringClass()) throw new ClassCastException(); return self.ordinal - other.ordinal; } public final Class&lt;E&gt; getDeclaringClass() { Class clazz = getClass(); Class zuper = clazz.getSuperclass(); return (zuper == Enum.class) ? clazz : zuper; } //valueOf(String name)调用该方法 public static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt; enumType,String name) { T result = enumType.enumConstantDirectory().get(name); if (result != null) return result; if (name == null) throw new NullPointerException(&quot;Name is null&quot;); throw new IllegalArgumentException( &quot;No enum constant &quot; + enumType.getCanonicalName() + &quot;.&quot; + name); }","tags":[{"name":"JAVA基础","slug":"JAVA基础","permalink":"https://mcgwinds.github.io/tags/JAVA基础/"}]},{"title":"AbstractStringBuilder","date":"2017-01-29T02:13:23.000Z","path":"2017/01/29/AbstractStringBuilder/","text":"String是不变字符串，而要实现可变字符串，可以通过继承AbstractStringBuilder类，AbstractStringBuilder是抽象类，实现了Appendable，CharSequence接口，具有append能力，同时也具备了返回字符串长度，返回特定位置字符，返回子串等能力，是StringBuilder和StringBuffer的父类。 类定义: abstract class AbstractStringBuilder implements Appendable, CharSequence 从类定义看，AbstractStringBuilder是包私有。 属性: 私有属性: char value[];（value数组保存字符串，不是final类型） int count; 字符串的长度 方法: AbstractStringBuilder提供了2个构造函数： //默认构造函数。 AbstractStringBuilder() { } //以capacity参数创建保存字符串的数组。 AbstractStringBuilder(int capacity) { value = new char[capacity]; } append()函数系列 public AbstractStringBuilder append(Object obj) public AbstractStringBuilder append(String str) public AbstractStringBuilder append(StringBuffer sb) public AbstractStringBuilder append(CharSequence s) public AbstractStringBuilder append(CharSequence s, int start, int end) public AbstractStringBuilder append(char[] str) public AbstractStringBuilder append(char str[], int offset, int len) public AbstractStringBuilder append(boolean b) public AbstractStringBuilder append(char c) public AbstractStringBuilder append(int i) public AbstractStringBuilder append(long l) public AbstractStringBuilder append(float f) public AbstractStringBuilder append(double d) insert()函数系列 public AbstractStringBuilder insert(int index, char[] str, int offset,int len) public AbstractStringBuilder insert(int offset, Object obj) public AbstractStringBuilder insert(int offset, String str) public AbstractStringBuilder insert(int offset, char[] str) public AbstractStringBuilder insert(int dstOffset, CharSequence s public AbstractStringBuilder insert(int dstOffset, CharSequence s,int start, int end) public AbstractStringBuilder insert(int offset, boolean b) public AbstractStringBuilder insert(int offset, char c) public AbstractStringBuilder insert(int offset, int i) public AbstractStringBuilder insert(int offset, long l) public AbstractStringBuilder insert(int offset, float f) public AbstractStringBuilder insert(int offset, double d) 在append和insert等函数的时候，需要判断进行数组扩容，expandCapacity函数完成数组的扩容，具体处理逻辑如下： void expandCapacity(int minimumCapacity) { //原来数组的两倍+2(为什么这样设置，而不是2倍或其他) int newCapacity = value.length * 2 + 2; if (newCapacity - minimumCapacity &lt; 0) //如果newCapacity小于minimumCapacity，则将扩容大小设置为minimumCapacity newCapacity = minimumCapacity; if (newCapacity &lt; 0) { if (minimumCapacity &lt; 0) // overflow throw new OutOfMemoryError(); newCapacity = Integer.MAX_VALUE; } //调用Arrays.copyOf将value复制到扩容后的数组 value = Arrays.copyOf(value, newCapacity); } public void ensureCapacity(int minimumCapacity) //子类可以调用的方法实现扩容，在方法中调用ensureCapacityInternal private void ensureCapacityInternal(int minimumCapacity) //ensureCapacityInternal调用ensureCapacityInternal 其他方法 public int length() 返回字符串长度 public int capacity() 返回数组大小 public AbstractStringBuilder appendCodePoint(int codePoint) public charAt(int index) 返回字符串中第（index+1）个字符 public AbstractStringBuilder deleteCharAt(int index) public void setLength(int newLength) 设置字符串长度为newLength，如果newLength长度大于count，则以newLength为字符串长度，同时[count,newLengt-1]区间设置字符为&apos;/0&apos;;当newLength长度小于count，则字符串value[0,newLength-1] public void trimToSize() 如果字符串小于数组长度，将数组长度设置为字符串 public int indexOf(String str) //返回str在字符串中的位置 public int lastIndexOf(String str) //返回str在字符串中最后的位置 public AbstractStringBuilder reverse()//反转 final char[] getValue() 返回数组 public String substring(int start, int end) public CharSequence subSequence(int start, int end) public AbstractStringBuilder replace(int start, int end, String str) StringBuilder public final class StringBuilder extends AbstractStringBuilder implements java.io.Serializable, CharSequence 构造函数 public StringBuilder() { super(16);//默认创建数组大小为16 } public StringBuilder(int capacity) public StringBuilder(String str) { super(str.length() + 16); append(str); } public StringBuilder(CharSequence seq) { this(seq.length() + 16); append(seq); } 其他方法覆盖了AbstractStringBuilder中的方法，然后在方法体内调用对应的AbstractStringBuilder方法。 StringBuffer StringBuffer与StringBuilder类似，只是方法用synchronized进行了修饰。","tags":[{"name":"JAVA基础","slug":"JAVA基础","permalink":"https://mcgwinds.github.io/tags/JAVA基础/"}]},{"title":"String","date":"2017-01-22T06:21:45.000Z","path":"2017/01/22/String/","text":"String表示字符串，Java中所有字符串的字面值都是String类的实例。例如”hello world”,在定义之后就不能被改变。 类定义: public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence String类实现了Serializable，Comparable,CharSequence接口。String类是final类，也就是说String类没有子类，为什么将String定义为final类型？我的理解是防止子类通过多态修改字符串。 CharSequence接口 CharSequence接口代表了一个只读的字符串，StringBuffer，StringBuilder也实现了该接口，该接口提供了4个方法： int length();返回字符串长度 char charAt(int index);返回特定位置字符 CharSequence subSequence(int start, int end);返回子串 public String toString(); 属性: 私有属性: private final char value[];（value数组保存字符串，定义为final类型） 方法: String提供了10几种构造函数： //默认构造函数。 public String() { this.value = new char[0]; } //以String参数构造一个新分配的String 对象。 public String(String original) { this.value = original.value; this.hash = original.hash; } //以char数组为参数 public String(char value[]) { this.value = Arrays.copyOf(value, value.length); } 在Java中，String实例中保存有一个char[]字符数组，char[]字符数组是以unicode码来存储的，String 和 char 为内存形式，byte是网络传输或存储的序列化形式。所以在很多传输和存储的过程中需要将byte[]数组和String进行相互转化。所以，String提供了一系列重载的构造方法来将一个字符数组转化成String，提到byte[]和String之间的相互转换就不得不关注编码问题。String(byte[] bytes, Charset charset)是指通过charset来解码指定的byte数组，将其解码成unicode的char[]数组，够造成新的String。 这里的bytes字节流是使用charset进行编码的，想要将他转换成unicode的char[]数组，而又保证不出现乱码，那就要指定其解码方式 String(byte bytes[]) String(byte bytes[], int offset, int length) String(byte bytes[], Charset charset) String(byte bytes[], String charsetName) String(byte bytes[], int offset, int length, Charset charset) 如果我们在使用byte[]构造String的时候，使用的是上面这四种构造方法(带有charsetName或者charset参数)的一种的话，那么就会使用StringCoding.decode方法进行解码，使用的解码的字符集就是我们指定的charsetName或者charset。 我们在使用byte[]构造String的时候，如果没有指明解码使用的字符集的话，那么StringCoding的decode方法首先调用系统的默认编码格式，如果没有指定编码格式则默认使用ISO-8859-1编码格式进行编码操作。主要体现代码如下： static char[] decode(byte[] ba, int off, int len) { String csn = Charset.defaultCharset().name(); try { // use charset name decode() variant which provides caching. return decode(csn, ba, off, len); } catch (UnsupportedEncodingException x) { warnUnsupportedCharset(csn); } try { return decode(&quot;ISO-8859-1&quot;, ba, off, len); } catch (UnsupportedEncodingException x) { // If this code is hit during VM initialization, MessageUtils is // the only way we will be able to get any kind of error message. MessageUtils.err(&quot;ISO-8859-1 charset not available: &quot;+ x.toString()); // If we can not find ISO-8859-1 (a required encoding) then things // are seriously wrong with the installation. System.exit(1); return null; } } getBytes 在创建String的时候，可以使用byte[]数组，将一个字节数组转换成字符串，同样，我们可以将一个字符串转换成字节数组，那么String提供了很多重载的getBytes方法。但是，值得注意的是，在使用这些方法的时候一定要注意编码问题。比如： String s = &quot;你好，世界！&quot;; byte[] bytes = s.getBytes(); 这段代码在不同的平台上运行得到结果是不一样的。由于我们没有指定编码方式，所以在该方法对字符串进行编码的时候就会使用系统的默认编码方式，比如在中文操作系统中可能会使用GBK或者GB2312进行编码，在英文操作系统中有可能使用iso-8859-1进行编码。这样写出来的代码就和机器环境有很强的关联性了，所以，为了避免不必要的麻烦，我们要指定编码方式。如使用以下方式： String s = &quot;你好，世界！&quot;; byte[] bytes = s.getBytes(&quot;utf-8&quot;); 其他方法 length() 返回字符串长度 isEmpty() 返回字符串是否为空 charAt(int index) 返回字符串中第（index+1）个字符 char[] toCharArray() 转化成字符数组 trim() 去掉两端空格 toUpperCase() 转化为大写 toLowerCase() 转化为小写 String concat(String str) //拼接字符串 String replace(char oldChar, char newChar) //将字符串中的oldChar字符换成newChar字符 //以上两个方法都使用了String(char[] value, boolean share)； boolean matches(String regex) //判断字符串是否匹配给定的regex正则表达式 boolean contains(CharSequence s) //判断字符串是否包含字符序列s String[] split(String regex, int limit) 按照字符regex将字符串分成limit份。 String[] split(String regex) boolean equalsIgnoreCase(String anotherString)//比较大小 boolean contentEquals(StringBuffer sb)； boolean contentEquals(CharSequence cs) boolean endsWith(String suffix) //是否以suffix结尾 boolean startsWith(String prefix, int toffset)//是否以prefix开始 int compareTo(String anotherString)； int compareToIgnoreCase(String str)； boolean regionMatches(int toffset, String other, int ooffset,int len) //局部匹配 boolean regionMatches(boolean ignoreCase, int toffset,String other, int ooffset, int len) //局部匹配","tags":[{"name":"JAVA基础","slug":"JAVA基础","permalink":"https://mcgwinds.github.io/tags/JAVA基础/"}]},{"title":"Byte","date":"2017-01-13T13:00:34.000Z","path":"2017/01/13/Byte/","text":"Byte类是基本类型byte的包装类。 类定义: public final class Byte extends Number implements Comparable&lt;Byte&gt; 属性: 私有属性: private final byte value;（value属性就是Byte对象中真正保存int值的） 公共属性: public static final byte MIN_VALUE = -128; public static final byte MAX_VALUE = 127; public static final Class&lt;Byte&gt; TYPE = Class.getPrimitiveClass(&quot;byte&quot;); public static final int SIZE = 8; 方法: Integer提供了两个构造方法： //构造一个新分配的 Byte 对象，它表示指定的 byte 值。 public Byte(byte arg0) { this.value = arg0; } //构造一个新分配的 Byte 对象，它表示 String 参数所指示的 byte 值。 public Byte(String arg0) throws NumberFormatException { this.value = parseByte(arg0, 10); } Byte valueOf(byte arg)方法（effective java第一条准则）: //valueOf方法源码 public static Byte valueOf(byte arg) { return Byte.ByteCache.cache[arg + 128]; } Byte类和Integer一样，调用valueOf方法时，会从缓存中取，不过不同的是Byte类调用valueOf取得都是缓存ByteCache中的值。 private static class ByteCache { static final Byte[] cache = new Byte[256]; static { for (int arg = 0; arg &lt; cache.length; ++arg) { cache[arg] = new Byte((byte) (arg - 128)); } } } 作为Byte类的静态内部类，和Byte类一起加载，加载过程中会创建一个长度为256的数组，同时在静态内部块中初始化。 String转成Byte（byte）的方法: Byte decode(String arg) Byte valueOf(String arg, int arg0) byte parseByte(String arg) byte parseByte(String arg, int arg0) 上述方法都是直接或间接的先将String转化为int类型，例如parseByte(String arg, int arg0)方法首先将String转化为int，然后判断该值是否在[-128，127]之间。 public static byte parseByte(String arg, int arg0) throws NumberFormatException { int arg1 = Integer.parseInt(arg, arg0); if (arg1 &gt;= -128 &amp;&amp; arg1 &lt;= 127) { return (byte) arg1; } else { throw new NumberFormatException(&quot;Value out of range. Value:\\&quot;&quot; + arg + &quot;\\&quot; Radix:&quot; + arg0); } } int转成String的方法: String toString(byte arg) Byte的toString(byte arg)方法调用的是Integer的toString(byte arg，10)方法。 compareTo方法: Byte类实现了Comparable接口，所以Byte对象可以和另外一个Byte对象进行比较。 public int compareTo(Byte arg0) { return compare(this.value, arg0.value); } public static int compare(byte arg, byte arg0) { return arg - arg0; } 代码实现比较简单，就是拿出其中的byte类型的value进行比较。","tags":[{"name":"JAVA基础","slug":"JAVA基础","permalink":"https://mcgwinds.github.io/tags/JAVA基础/"}]},{"title":"Boolean","date":"2017-01-12T13:29:34.000Z","path":"2017/01/12/Boolean/","text":"Boolean类是基本类型boolean的包装类。 类定义: public final class Boolean implements Serializable, Comparable&lt;Boolean&gt; 类的定义与Integer类似，这里就不累赘了。 属性: 私有属性: private final boolean value;（value属性就是Boolean对象中真正保存boolean值的） 当我们使用new Boolean(True)创建一个Boolean对象的时候，就会用以下形式给value赋值 public Boolean(boolean arg0) { this.value = arg0; } 公共属性: //ture对应的Boolean静态常量。 public static final Boolean TRUE = new Boolean(true); //false对应的Boolean静态常量 public static final Boolean FALSE = new Boolean(false); public static final Class&lt;Boolean&gt; TYPE = Class .getPrimitiveClass(&quot;boolean&quot;); 方法: Boolean提供了两个构造方法： //构造一个新分配的 Boolean 对象，它表示指定的 boolean 值。 public Boolean(boolean arg0) { this.value = arg0; } //构造一个新分配的 Boolean 对象，它表示 String 参数所指示的 boolean 值。 public Boolean(String arg0) { this(toBoolean(arg0)); } Boolean valueOf(boolean i)方法: //valueOf方法源码 public static Boolean valueOf(boolean arg) { return arg ? TRUE : FALSE; } 当参数是true时取常量TRUE，当参数是false时取常量FALSE。 String转成Boolean的方法: boolean getBoolean(String arg) boolean toBoolean(String arg) parseBoolean(String arg) Boolean valueOf(String arg) getBoolean: public static boolean getBoolean(String arg) { boolean arg0 = false; try { arg0 = toBoolean(System.getProperty(arg)); } catch (IllegalArgumentException arg2) { ; } catch (NullPointerException arg3) { ; } return arg0; } 确定具有指定名称的系统属性的Boolean值。 toBoolean: private static boolean toBoolean(String arg) { return arg != null &amp;&amp; arg.equalsIgnoreCase(&quot;true&quot;); } 将参数与字符串true进行比较 parseBoolean: public static boolean parseBoolean(String arg) { return toBoolean(arg); } 该方法调用toBoolean，将String转化为boolean。 boolean转成String的方法: String toString(boolean arg) 直接看toString方法，toString方法的定义比较简单，就是把一个boolean类型转换成字符串类型。 public static String toString(boolean arg) { return arg ? &quot;true&quot; : &quot;false&quot;; } compareTo方法: public int compareTo(Boolean arg0) { return compare(this.value, arg0.value); } public static int compare(boolean arg, boolean arg0) { return arg == arg0 ? 0 : (arg ? 1 : -1); } 代码实现比较简单，就是拿出其中的boolean类型的value进行比较。","tags":[{"name":"JAVA基础","slug":"JAVA基础","permalink":"https://mcgwinds.github.io/tags/JAVA基础/"}]},{"title":"Integer","date":"2017-01-11T04:29:34.000Z","path":"2017/01/11/Integer/","text":"Integer类是基本类型int的包装类。 类定义: public final class Integer extends Number implements Comparable&lt;Integer&gt; 从类定义中我们可以知道以下几点： 1、Integer类不能被继承 2、Integer类实现了Comparable接口，所以可以用compareTo进行比较并且Integer对象只能和Integer类型的对象进行比较，不能和其他类型比较（至少调用compareTo方法无法比较）。 3、Integer继承了Number类，所以该类可以调用longValue、floatValue、doubleValue等系列方法返回对应的类型的值。 属性: 私有属性: private final int value;（value属性就是Integer对象中真正保存int值的） 当我们使用new Integer(10)创建一个Integer对象的时候，就会用以下形式给value赋值 public Integer(int value) { this.value = value; } 从value的定义形式中可以看出value被定义成final类型。也就说明，一旦一个Integer对象被初始化之后，就无法再改变value的值。 这里深入讨论一下以下代码的逻辑： public class IntegerTest { public static void main(String[] args) { Integer i = new Integer(10); i = 5; } } 在以上代码中，首先调用构造函数new一个Integer对象，给私有属性value赋值，这时value=10,接下来使用i=5的形式试图改变i的值。 有一点开发经验的同学都知道，这个时候如果使用变量i，那么它的值一定是5，那么i=5这个赋值操作到底做了什么呢？到底是如何改变i的值的呢？是改变了原有对象i中value的值还是重新创建了一个新的Integer对象呢？ 其实上面的代码编译阶段编译器就会把i=5转成i = Integer.valueOf(5)[包装操作];这里先直接给出结论，i=5操作并没有改变使用Integer i = new Integer(10);创建出来的i中的value属性的值。要么是直接返回一个已有对象，要么新建一个对象。这里的具体实现细节在后面讲解valueOf方法的时候给出。公共属性: //值为 （－（2的31次方）） 的常量，它表示 int 类型能够表示的最小值。 public static final int MIN_VALUE = 0x80000000; //值为 （（2的31次方）－1） 的常量，它表示 int 类型能够表示的最大值。 public static final int MAX_VALUE = 0x7fffffff; //表示基本类型 int 的 Class 实例。 public static final Class&lt;Integer&gt; TYPE = (Class&lt;Integer&gt;) Class.getPrimitiveClass(&quot;int&quot;); //用来以二进制补码形式表示 int 值的比特位数。 public static final int SIZE = 32; 方法: Integer提供了两个构造方法： //构造一个新分配的 Integer 对象，它表示指定的 int 值。 public Integer(int value) { this.value = value; } //构造一个新分配的 Integer 对象，它表示 String 参数所指示的 int 值。 public Integer(String s) throws NumberFormatException { this.value = parseInt(s, 10); } Integer valueOf(int i)方法（effective java第一条准则）: //valueOf方法源码 public static Integer valueOf(int i) { if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); } 我们看到了在valueOf方法中有一个if表达式，当i小于IntegerCache中high属性，大于IntegerCache中low属性时，返回IntegerCache中cache数组中与i相关的某个值，从名义上可以看出IntegerCache是Integer的缓存，那么IntegerCache又是怎样实现的呢？ private static class IntegerCache { static final int low = -128; static final int high; static final Integer[] cache; static { int arg = 127; String arg0 = VM .getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;); int arg1; if (arg0 != null) { arg1 = Integer.parseInt(arg0); arg1 = Math.max(arg1, 127); arg = Math.min(arg1, 2147483518); } high = arg; cache = new Integer[high - -128 + 1]; arg1 = -128; for (int arg2 = 0; arg2 &lt; cache.length; ++arg2) { cache[arg2] = new Integer(arg1++); } } } 以上是IntegerCache的源码，IntegerCache有三个属性：low=-128，high（通常=127），cache数组，一个静态代码块。IntegerCache的源码结构可知，当加载Integer类时，因为IntegerCache是静态内部类所以会被加载，同时会执行静态代码块，在静态代码块中给high赋值，同时创建cache数组并赋值，cache数组的长度为(high - low) + 1。 所以valueOf方法的if表达式其实取的是IntegerCache中cache数组的值，这么做的好处就是当i在[low high]范围内，就不用重复创建对象，直接从cache中取。 String转成Integer（int）的方法: Integer getInteger(String nm) Integer getInteger(String nm, int val) Integer getInteger(String nm, Integer val) Integer decode(String nm) Integer valueOf(String s) Integer valueOf(String s, int radix) int parseUnsignedInt(String s) int parseUnsignedInt(String s, int radix) int parseInt(String s) int parseInt(String s, int radix) 以上所有方法都能实现将String类型的值转成Integer(int)类型（如果 String 不包含可解析整数将抛出NumberFormatException） 可以说，所有将String转成Integer的方法都是基于parseInt方法实现的。简单看一下以上部分方法的调用栈。 getInteger(String nm) ---&gt; getInteger(nm, null);---&gt;Integer.decode()---&gt;Integer.valueOf()---&gt;parseInt() getInteger: 确定具有指定名称的系统属性的整数值。 第一个参数被视为系统属性的名称。通过 System.getProperty(java.lang.String) 方法可以访问系统属性。然后，将该属性的字符串值解释为一个整数值，并返回表示该值的 Integer 对象。使用 getProperty 的定义可以找到可能出现的数字格式的详细信息。其中参数nm应该在System的props中可以找到。 decode: public static Integer decode(String nm) throws NumberFormatException 该方法的作用是将 String 解码为 Integer。接受十进制、十六进制和八进制数字。 parseInt: public static int parseInt(String s) throws NumberFormatException { return parseInt(s,10); } public static int parseInt(String s, int radix) throws NumberFormatException 使用第二个参数指定的基数(如果没指定，则按照十进制处理），将字符串参数解析为有符号的整数。如果发生以下任意一种情况，则抛出一个 NumberFormatException 类型的异常： 1.第一个参数为 null 或一个长度为零的字符串。 2.基数小于 Character.MIN_RADIX 或者大于 Character.MAX_RADIX。 3.假如字符串的长度超过 1，那么除了第一个字符可以是减号 ‘-‘ (‘u002D’) 外，字符串中存在任意不是由指定基数的数字表示的字符. 4.字符串表示的值不是 int 类型的值。 总结: 上面列举了很多能够将String转成Integer的方法。那么他们之间有哪些区别，又该如何选择呢？ parseInt方法返回的是基本类型int 其他的方法返回的是Integer valueOf（String）方法会调用valueOf(int)方法。 如果只需要返回一个基本类型，而不需要一个对象，可以直接使用Integert.parseInt(“123”); 如果需要一个对象，那么建议使用valueOf(),因为该方法可以借助缓存带来的好处。 如果和进制有关，那么就是用decode方法。 如果是从系统配置中取值，那么就是用getInteger int转成String的方法: String toString() static String toString(int i) static String toString(int i, int radix) static String toBinaryString(int i) static String toHexString(int i) static String toOctalString(int i) static String toUnsignedString(int i) static String toUnsignedString(int i, int radix) 直接看toString方法，toString方法的定义比较简单，就是把一个int类型的数字转换成字符串类型，但是这个方法的实现调用了一系列方法。 public static String toString(int i) { if (i == Integer.MIN_VALUE) //下面代码要将负数转化为正数 return &quot;-2147483648&quot;; int size = (i &lt; 0) ? stringSize(-i) + 1 : stringSize(i); char[] buf = new char[size]; getChars(i, size, buf); return new String(buf, true); } compareTo方法: Integer类实现了Comparable接口，所以Integer对象可以和另外一个Integer对象进行比较。 public int compareTo(Integer anotherInteger) { return compare(this.value, anotherInteger.value); } public static int compare(int x, int y) { return (x &lt; y) ? -1 : ((x == y) ? 0 : 1); } 代码实现比较简单，就是拿出其中的int类型的value进行比较。 参考资料 http://www.hollischuang.com/archives/1058","tags":[{"name":"JAVA基础","slug":"JAVA基础","permalink":"https://mcgwinds.github.io/tags/JAVA基础/"}]}]