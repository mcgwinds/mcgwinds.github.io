[{"title":"AOP","date":"2017-07-23T04:39:14.000Z","path":"2017/07/23/aspect/","text":"有时候需要在很多代码模块中引入一些公共的行为，例如日子，权限校验。如果在每个模块中都写，将引入很多重复的代码，耦合度太高，程序也不便于维护。运用一种称为AOP的技术可以实现公共行为的同时，也不会需要大量的维护成本，书写大量的代码。 AOP中文叫做面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术，AOP关注的方向是横向，不同于面向对象编程中关注的纵向。方式上有动态AOP和静态AOP。 AOP相关术语 Joinpoint 连接点 指那些被拦截到的点.在Spring中,这些点指方法(因为Spring只支持方法类型的连接点). Pointcut 切入点 指需要(配置)被增强的Joinpoint. Advice 通知/增强 指拦截到Joinpoint后要做的操作.通知分为前置通知/后置通知/异常通知/最终通知/环绕通知等. Aspect 切面 切入点和通知的结合. Target 目标对象 需要被代理(增强)的对象. Proxy 代理对象 目标对象被AOP 织入 增强/通知后,产生的对象. Weaving 织入 指把增强/通知应用到目标对象来创建代理对象的过程(Spring采用动态代理织入,AspectJ采用编译期织入和类装载期织入). Introduction 引介 一种特殊通知,在不修改类代码的前提下,可以在运行期为类动态地添加一些Method/Field(不常用). 动态AOP 实现方式：JDK动态代理：代理对象必须实现某个接口 cglib动态代理：通过在运行期生产目标对象的扩展子类 Spring中AOP实现方式: 1.经典的基于代理的AOP 2.使用AspectJ注解 通过配置 3.纯POJO切面 通过配置 4.注入式AspectJ切面 2,3两种AOP方式的配置，它们是一种自定义的标签，需要一套自定义的一套解析机制，注册的对应的解析器在AOPNamespaceHandler的init方法中。 public void init() { registerBeanDefinitionParser(&quot;config&quot;, new ConfigBeanDefinitionParser()); registerBeanDefinitionParser(&quot;aspectj-autoproxy&quot;, new AspectJAutoProxyBeanDefinitionParser()); registerBeanDefinitionDecorator(&quot;scoped-proxy&quot;, new ScopedProxyBeanDefinitionDecorator()); registerBeanDefinitionParser(&quot;spring-configured&quot;, new SpringConfiguredBeanDefinitionParser()); } aspectj-autoproxy对应的是AspectJAutoProxyBeanDefinitionParser，config对应的是ConfigBeanDefinitionParser。在这两个类的解析方法中，都会对应创建AbstractAutoProxyCreator子类的beanDefinition，AbstractAutoProxyCreator实现了BeanPostProcessor接口。在getbean的时候，会调用AbstractAutoProxyCreator的postProcessBeforeInstantiation方法。 静态AOP 静态AOP的实现主要通过在虚拟机启动时修改目标对象字节码的方式，完成对目标对象的能力增强，与动态代理相比效率更高，因为在动态代理调用过程中，需要动态创建一个代理类并代理目标对象，而静态代理启动时便完成了字节码增强，当系统调用目标类与调用正常的类并无差别。 实现 通过javaagent","tags":[{"name":"Spring","slug":"Spring","permalink":"https://mcgwinds.github.io/tags/Spring/"}]},{"title":"dubbo(3)->Spring的运用(1)","date":"2017-07-16T12:39:14.000Z","path":"2017/07/16/dubbo中spring的运用/","text":"spring是大家熟悉的，而且经常用到的一个成熟框架，通过spring可以将对象的创建交给框架，从而实现解耦。Spring有两大重要的特性：IoC，AOP。IoC是依赖注入，AOP是面向切面编程。 dubbo中是如何运用spring的呢？ dubbo中关于spring的运用主要在dubbo-config-spring包。打开该包，发现也就8个类，这篇博客主要讲解DubboBeanDefinitionParser、DubboNamespaceHandler。另外的三个类ServiceBean、ReferenceBean、AnnotationBean在叙述上面两个类的时候会涉及到，其他的类这里暂不讨论。看dubbo的spring配置发现，其中的有些节点以dubbo:service dubbo：application开头。其实这是dubbo扩展了spring。下面分析dubbo是怎样扩展运用spring与自己的配置结合起来的。 DubboBeanDefinitionParser类： public class DubboBeanDefinitionParser implements BeanDefinitionParser 上面是DubboBeanDefinitionParser类的定义，DubboBeanDefinitionParser类实现了BeanDefinitionParser，查看spring的源码会发现BeanDefinitionParser接口用于解析xml文件中的配置，然后将配置转化为java模型。解析通过实现parse方法实现，在parse方法主要完成element对象的解析，同时将解析的属性转化到beanDefinition中，具体解析逻辑就不叙述。 DubboBeanDefinitionParser类用于解析，那解析过程中是怎样找到该类的，为什么不是其他的BeanDefinitionParser。这就要看DubboNamespaceHandler类。 DubboNamespaceHandler类: public class DubboNamespaceHandler extends NamespaceHandlerSupport DubboNamespaceHandler类继承了NamespaceHandlerSupport类，DubboNamespaceHandler类就一个init方法。 public void init() { registerBeanDefinitionParser(&quot;application&quot;, new DubboBeanDefinitionParser(ApplicationConfig.class, true)); registerBeanDefinitionParser(&quot;module&quot;, new DubboBeanDefinitionParser(ModuleConfig.class, true)); registerBeanDefinitionParser(&quot;registry&quot;, new DubboBeanDefinitionParser(RegistryConfig.class, true)); registerBeanDefinitionParser(&quot;monitor&quot;, new DubboBeanDefinitionParser(MonitorConfig.class, true)); registerBeanDefinitionParser(&quot;provider&quot;, new DubboBeanDefinitionParser(ProviderConfig.class, true)); registerBeanDefinitionParser(&quot;consumer&quot;, new DubboBeanDefinitionParser(ConsumerConfig.class, true)); registerBeanDefinitionParser(&quot;protocol&quot;, new DubboBeanDefinitionParser(ProtocolConfig.class, true)); registerBeanDefinitionParser(&quot;service&quot;, new DubboBeanDefinitionParser(ServiceBean.class, true)); registerBeanDefinitionParser(&quot;reference&quot;, new DubboBeanDefinitionParser(ReferenceBean.class, false)); registerBeanDefinitionParser(&quot;annotation&quot;, new DubboBeanDefinitionParser(AnnotationBean.class, true)); } 上面是init方法，其实init方法很简单，就是将节点与对应的解析器进行映射，这也就是为什么出现dubbo:service的时候，就会是DubboBeanDefinitionParser了。我们发现上面DubboBeanDefinitionParser第一个参数都是一个class，其实这个class就到时创建的对象，也就是说xml中service节点里面的描述会转化到servicebean，reference就对应ReferenceBean，annotation对应AnnotationBean。 那spring在解析过程中又是怎么找到DubboNamespaceHandler？同时我们知道xml都有一套规范，那dubbo又是运用了怎么的原理来让自己符合spring的规范的呢。 这里需要查看resources文件夹，在resources文件夹里面有dubbo.xsd spring.handlers spring.schemas dubbo.xsd：就是一套dubbo的xml定义规范 spring.handlers: http\\://code.alibabatech.com/schema/dubbo=com.alibaba.dubbo.config.spring.schema.DubboNamespaceHandler 这是spring.handlers里面的内容，就是建立映射，通过他找到DubboNamespaceHandler。 spring.schemas: http\\://code.alibabatech.com/schema/dubbo/dubbo.xsd=META-INF/dubbo.xsd 这个文件指定了xsd文件来自哪里。 这篇博客只是大体介绍了一下dubbo是如何运用spring的扩展标签的，其实运用spring的扩展标签可以在很多地方见到，spring框架内部就能见到，例如AOP里面有AOPNamespaceHandler用于对aop一些标签的定制其实特定化。","tags":[{"name":"Spring","slug":"Spring","permalink":"https://mcgwinds.github.io/tags/Spring/"}]},{"title":"dubbo(2)->Cooma","date":"2017-07-09T02:12:18.000Z","path":"2017/07/09/ExtensionLoader/","text":"前一篇文章总结了一下JDK的SPI机制，dubbo基于SPI基础上扩展了一套自己的SPI机制，通过ExtensionLoader类实现。第一次看ExtensionLoader源码，一脸懵逼，debug几次还是云里雾里。后来通过网上查资料，看到了Cooma，而Cooma的来源就是dubbo项目中的SPI。Cooma是一个独立的Java微容器，所以打算先从它讲起，后面的文章再分析dubbo框架中是如何运用ExtensionLoader的。 Cooma，官方介绍的已经非常详细了，这里大体说一下几个特点： 1）以插件方式加载扩展（SPI） 2）支持依赖扩展点的自动加载（IOC） 3 可以有扩展点Wrapper，为扩展写公共Filter代码（AOP） 下面通过分析Cooma源码来了解Cooma是这几大特点，Cooma的代码主要两个类Extension(把一个接口标识成扩展点)，ExtensionLoader(加载和管理扩展)。 Extension：是一个注解，通过Extension注解将一个接口标识成扩展点。 @Documented @Retention(RetentionPolicy.RUNTIME) @Target({ElementType.TYPE}) public @interface Extension { /** * the default extension name. * * @since 0.1.0 */ String value() default &quot;&quot;; } ExtensionLoader：ExtensionLoader类应该说是Cooma的核心，通过它实现扩展点（SPI）的加载，扩展点（IOC）的依赖注入，扩展点（AOP）的包装。 属性：加载相关属性： //扩展点的加载相对路径（对应JDk SPI的扩展点加载路径&quot;META-INF/service/&quot;） private static final String EXTENSION_CONF_DIRECTORY = &quot;META-INF/extensions/&quot;; //适配类key标识（对应dubbo中的Adaptive注解） private static final String PREFIX_ADAPTIVE_CLASS = &quot;*&quot;; //包装类key标识（对应dubbo中的cachedWrapperClasses） //private static final String PREFIX_WRAPPER_CLASS = &quot;+&quot;; //名字分隔 private static final Pattern NAME_SEPARATOR = Pattern.compile(&quot;\\\\s*,+\\\\s*&quot;); //名字校验 private static final Pattern NAME_PATTERN = Pattern.compile(&quot;[a-zA-Z0-9_]+&quot;); //类型与ExtensionLoader的映射，通过类型取对应的ExtensionLoader private static final ConcurrentMap&lt;Class&lt;?&gt;, ExtensionLoader&lt;?&gt;&gt; EXTENSION_LOADERS = new ConcurrentHashMap&lt;Class&lt;?&gt;, ExtensionLoader&lt;?&gt;&gt;(); 扩展点相关属性 private final Class&lt;T&gt; type; //默认扩展点 private final String defaultExtension; private final Holder&lt;Map&lt;String, Class&lt;?&gt;&gt;&gt; extClassesHolder = new Holder&lt;Map&lt;String, Class&lt;?&gt;&gt;&gt;(); private volatile Map&lt;String, Map&lt;String, String&gt;&gt; name2Attributes; private final ConcurrentMap&lt;Class&lt;?&gt;, String&gt; extClass2Name = new ConcurrentHashMap&lt;Class&lt;?&gt;, String&gt;(); //适配类，适配类唯一 private volatile Class&lt;?&gt; adaptiveClass = null; //包装类映射关系 private volatile Map&lt;String, Class&lt;? extends T&gt;&gt; name2Wrapper; 方法： //私有构造函数 private ExtensionLoader(Class&lt;T&gt; type) 设置ExtensionLoader的type属性，type属性用于获取type对应的所有扩展点，以及默认扩展点属性defaultExtension。 //获取类对应的ExtensionLoader public static &lt;T&gt; ExtensionLoader&lt;T&gt; getExtensionLoader(Class&lt;T&gt; type) 因为ExtensionLoader是私有的，所以只能通过该方法获取类对应的ExtensionLoader，该方法首先判断type是否为null，若为null则抛出参数异常，是否是接口，若不为接口则抛出参数异常，判断接口是否有Extension注解标识，若没有抛出参数一样。如果上述条件都通过，则根据类型到EXTENSION_LOADERS中取对应的EXTENSION_LOADERS，若为null，则新建一个ExtensionLoader，将类型作为key，ExtensionLoader为value放入map中。 获取扩展点： public T getExtension(String name) public T getExtension(String name, Map&lt;String, String&gt; properties) public T getExtension(Map&lt;String, String&gt; properties) public T getExtension(String name, List&lt;String&gt; wrappers) public T getExtension(String name, Map&lt;String, String&gt; properties, List&lt;String&gt; wrappers) name：扩展点对应的标识，通过类获取对应的扩展点，例如： impl1=com.alibaba.cooma.ext2.impl.Ext2Impl 通过name的impl1，可以获取Ext2Impl。properties：用于扩展点的依赖注入属性值wrappers：根据wrappers中的值从name2Wrapper中获取包装类。 getExtension扩展点的获取执行逻辑：1.createExtension获取扩展点然后实例化扩展点;2.inject依赖注入扩展点;若有包装类则对扩展类执行包装操作createWrapper; 获取扩展点然后实例化扩展点: createExtension——&gt;getExtensionClass——&gt;getExtensionClasses——&gt;loadExtensionClasses0——&gt;readExtension0 createExtension:执行getExtensionClass操作，获取扩展点class，然后实例化。 getExtensionClass：执行getExtensionClasses()操作，返回对应的extClassesHolder map，然后根据参数name，获取对应的扩展点class。 getExtensionClasses：判断extClassesHolder中是否有值，没有调用loadExtensionClasses0进行加载。 loadExtensionClasses0：根据fileName = EXTENSION_CONF_DIRECTORY + type.getName()[META-INF/extensions/{type}],获取文件，调用readExtension0获取文件内容。 readExtension0：按行读取文件内容，如果name以PREFIX_ADAPTIVE_CLASS，这该扩展点是一个适配类，若以PREFIX_WRAPPER_CLASS开头，则该类是一个包装类，判断构造函数是否正确。若既不是适配类，也不是包装类，则判断是否有默认构造函数。 依赖注入： private T inject(T instance, Map properties) 遍历扩展点实例的所有方法，方法名以set开头，参数个数为1，方法是public方法，若属性也是一个扩展点，则获取扩展点，然后通过反射进行依赖注入。 扩展点的包装： private T createWrapper(T instance, Map&lt;String, String&gt; properties, List&lt;String&gt; wrappers) 遍历wrappers，取出对应的包装类，包装类也是一个扩展点，它的职责就是对具体的扩展点进行能力增强。得到包装类以后，获取包含参数为扩展的构造函数，然后进行依赖注入。 获取默认的扩展点： public T getDefaultExtension() public T getDefaultExtension(List&lt;String&gt; wrappers) 以参数defaultExtension调用getExtension获取扩展点。 通过上面的分析，其实使用Cooma很容易，首先建立接口，然后在接口上注@Extension(“”)注解，基于该接口新建扩展点，在META-INF/extensions/{type}下书写扩展点，调用getExtensionLoader获得ExtensionLoader，通过获得的ExtensionLoader的getExtension方法获取扩展点实例。 参考：https://github.com/alibaba/cooma/wiki","tags":[{"name":"Cooma","slug":"Cooma","permalink":"https://mcgwinds.github.io/tags/Cooma/"}]},{"title":"程序员","date":"2017-03-18T15:05:14.000Z","path":"2017/03/18/Programmer/","text":"从最早接触C言语，再到C++，perl，到现在的java，涉及软件世界也有些许年了，编程一直是自己很喜欢的事。工作快两年了,怎样成为程序员,一直在不断地思考、探索？因为在自己心中，程序员职业一直是充满艺术性的，程序员是艺术家（艺术家：具有较高的审美能力和娴熟的创造技巧并从事艺术创作劳动而有一定成就的艺术工作者），是一个源于自然，发于心灵的艺术作品创作者。这世界，程序员太少，码农太多，自己现在也是一个活生生的码农。不知是哪个聪明的人发明的这么恰当的词汇“码农”。不过，很多时候一周能搬几行代码，砌个功能也是一种奢望，因为总有一堆公司琐事在困扰的你。 今天网上看到一篇老外写的文章关于怎样成为程序员，对自己很有指导意义，总结起来分下面5点：1.问题分解： 编程是解决问题，在你开始写任何代码之前，你应该有一套清晰的解决问题的方法论。程序员，能够将问题不断分解为更小部分，直到这些部分可以解决。同时会选出最合适的一种方法，方便实现，方便测试。2.方案分析： 程序员应该具备考虑多种场景的能力。在不同的场景下，结果很有可能南辕北辙。例如：如果参数时null，会发生什么；如这些条件都为true，又会怎样；该方法是否同步，并发场景下又改怎么处理。换句话说，程序员也是测试人员。相反的，码农很有可能考虑的只有一种发生的场景，对不其他场景触发的错误就没有不知道如何去cover。3.命名： 在程序设计中会涉及到大量的命名：类，方法，变量。程序设计的代码其实就是一份文档，通过名字就能大体清楚代码的功能。其实，能合适的命名是困难的，因为需要你清楚的知道每个名字代表的含义。4.连贯性： 连贯性是一个重要的性质。涉及各种变量命名，方法名，模块的分解，目录结构，错误处理，日志记录，文档等等。例如：一些相关变量一起出现在用到它们的时候，当有一个丢失的时候，能帮助你更快的发现。5.学习 作为程序员，你需要不断地学习。在增加一个新的特征的时候，你需要明白背后含义。当增加一段代码到程序中，应该知道放何处，怎么放是合适的。同时深入理解开发的程序，能够正确的处理。当你有较强的学习能力的时候，将会成为有效的开发者。程序的世界知识，框架，技术更新很快，信息量又巨大。你应该具有辨别什么是好的，什么是不好的能力。 路漫漫其修远兮 吾将上下而求索 愿自己早日成为程序员。","tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://mcgwinds.github.io/tags/杂谈/"}]},{"title":"RPC框架","date":"2017-03-12T12:39:14.000Z","path":"2017/03/12/rpc/","text":"分布式服务框架：用于实现服务复用，由一个RPC框架，注册中心，监控中心组成。大体会部署在应用层和数据层之间。其中RPC框架是最重要的部分，由服务端和客户端两部分组成，服务端暴露服务，会将服务信息注册到注册中心，客户端调用服务，会从注册中心获取服务信息，然后与服务端进行交互。实现一个高并发、高可用、高性能的的RPC框架涉及很多技术点。 下面是一个简单的RPC框架showcase，没有涉及注册中心，监控中心，服务端启动通过export方法暴露服务，客户端启动通过refer方法引用服务。 //暴露服务： package com.mcg.rpc.server; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Method; import java.net.ServerSocket; import java.net.Socket; public class Provider { public static void export(final Object instance, int port) throws Exception { if(instance==null) throw new IllegalArgumentException(&quot;service is null&quot;); if (port &gt; 65535) throw new IllegalArgumentException(port + &quot;is invalid&quot;); ServerSocket serverSocket = new ServerSocket(port); for(;;) { try { final Socket socket = serverSocket.accept(); new Thread(new Runnable() { public void run() { try { try { ObjectInputStream objectInputStream = new ObjectInputStream(socket.getInputStream()); try { String methodName = objectInputStream.readUTF(); Class&lt;?&gt;[] parameterTypes = (Class&lt;?&gt;[])objectInputStream.readObject(); Object[] arguments = (Object[])objectInputStream.readObject(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(socket.getOutputStream()); try { Method method = instance.getClass().getMethod(methodName, parameterTypes); Object result = method.invoke(instance, arguments); objectOutputStream.writeObject(result); } catch (Throwable t) { objectOutputStream.writeObject(t); } finally { objectOutputStream.close(); } } finally { objectInputStream.close(); } } finally { socket.close(); } } catch (Exception e) { e.printStackTrace(); } } }).start(); } catch (Exception e) { e.printStackTrace(); } } } } //引用服务： package com.mcg.rpc.client; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; import java.net.Socket; public class Consumer { @SuppressWarnings(&quot;unchecked&quot;) public static &lt;T&gt; T refer(final Class&lt;T&gt; serviceInterface,final String host,final int port) { return (T)Proxy.newProxyInstance(serviceInterface.getClassLoader(),new Class&lt;?&gt;[]{serviceInterface}, new InvocationHandler() { public Object invoke(Object proxy, Method method, Object[] arguments) throws Throwable { Socket socket = new Socket(host, port); try { ObjectOutputStream output = new ObjectOutputStream(socket.getOutputStream()); try { output.writeUTF(method.getName()); output.writeObject(method.getParameterTypes()); output.writeObject(arguments); ObjectInputStream input = new ObjectInputStream(socket.getInputStream()); try { Object result = input.readObject(); if (result instanceof Throwable) { throw (Throwable) result; } return result; } finally { input.close(); } } finally { output.close(); } } finally { socket.close(); } } }); } } //服务接口： package com.mcg.rpc.service; public interface HelloService { void say(String name); } //服务实现： package com.mcg.rpc.service; public class HelloServiceImpl implements HelloService { public void say(String name) { System.out.println(&quot;hello:&quot; + name); } } //测试: package com.mcg.rpc.server; import com.mcg.rpc.service.HelloService; import com.mcg.rpc.service.HelloServiceImpl; public class ServerTest { private final static int PORT=1234; public static void main(String args []) throws Exception { HelloService instance=new HelloServiceImpl(); Provider.export(instance, PORT); } } package com.mcg.rpc.client; import com.mcg.rpc.service.HelloService; public class ClientTest { private final static int PORT=1234; private final static String HOST=&quot;127.0.0.1&quot;; public static void main(String args []) { HelloService helloService=Consumer.refer(HelloService.class, HOST, PORT); helloService.say(&quot;mcg&quot;); } } //结果： hello:mcg","tags":[{"name":"RPC","slug":"RPC","permalink":"https://mcgwinds.github.io/tags/RPC/"}]},{"title":"dubbo(1)->Serviceloader","date":"2017-03-12T12:39:14.000Z","path":"2017/03/12/serviceloader/","text":"中间件技术一直都是自己最感兴趣，有分布式服务框架，分布式消息队列，分布式缓存，分布式数据服务等等，参与开发其中任一一个项目都会学到很多知识，很幸运在开始参加工作后的第一个项目就是分布式服务框架，后来接触到了dubbo，被dubbo的设计所吸引，虽然有时间偶尔也会看看dubbo的代码，但没有系统的好好总结沉淀下来，看得如同过往云烟，时间也就那样的流逝了。最近也不断地在反思，工作快2两年了，像是一直在原地踏步，很多时候都是急于求成，自知其然，却不知其所以然，看着距离自己的第一个目标还那么的远，所以决定好好的静下心来先从学dubbo开始。 dubbo是服务框架，服务框架是用于实现服务的复用的框架，是软件框架。那框架是什么？让我联想到了建筑框架，建筑框架确定了整个建筑的结构，建筑框架允许你在不改变结构的基础上，自由改变其内容。例如，你可以用墙体随意分隔房间。所以框架就好比建筑框架，可以这样说，框架的本质就是“扩展”。在一个框架中，实现丰富的功能固然重要，然而更重要的是：建立良好的扩展机制。 dubbo基于JDK中的SPI机制扩展了一套自己的扩展机制，让使用者方便地自己扩展和实现自己的插件。下面介绍JDK提供的SPI机制(java.util.ServiceLoader)： SPI英文为Service Provider Interface单从字面可以理解为Service提供者接口，正如从SPI的名字去理解SPI就是Service提供者接口；提供给服务提供厂商与扩展框架功能的开发者使用的接口。 SPI 机制的约定： 1) 在META-INF/services/目录中创建以接口全限定名命名的文件该文件内容为Api具体实现类的全限定名 2) 使用ServiceLoader类动态加载META-INF中的实现类 3) 如SPI的实现类为Jar则需要放在主程序classPath中 4) Api具体实现类必须有一个不带参数的构造方法 下面是基于JDK的SPI的showcase //工具类(对接用户和SPI)： package com.mcg.java.tool.serviceloader.utils; import java.util.ServiceLoader; import java.util.concurrent.ConcurrentHashMap; import java.util.concurrent.ConcurrentMap; //工具类 public class ServicerLoaderUtils { //保存spi加载的服务 private static ConcurrentMap&lt;String,Object&gt; services=new ConcurrentHashMap&lt;String,Object&gt;(); //用户调用方法,获取相应的服务 public static Object getService(String name,Class&lt;?&gt; clazz) throws Exception { Object service= services.get(name); if(null==service) { load(clazz); service= services.get(name); } return service; } //加载服务 public static &lt;T&gt; void load(Class&lt;T&gt; service) throws Exception { for (T t:ServiceLoader.load(service)) { String name=t.getClass().getAnnotation(ServiceAnnotation.class).name(); services.putIfAbsent(name, t); } } } //注解工具类： package com.mcg.java.tool.serviceloader.utils; import java.lang.annotation.Documented; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Documented @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) public @interface ServiceAnnotation { String name() default &quot;default&quot;; } //服务接口： package com.mcg.java.tool.serviceloader; public interface Handler { void handler(); } //服务实现： package com.mcg.java.tool.serviceloader.HandlerImpl; import com.mcg.java.tool.serviceloader.Handler; import com.mcg.java.tool.serviceloader.utils.ServiceAnnotation; @ServiceAnnotation public class DefaultHandlerImpl implements Handler { public void handler() { System.out.println(&quot;this is defaultHandler&quot;); } } package com.mcg.java.tool.serviceloader.HandlerImpl; import com.mcg.java.tool.serviceloader.Handler; import com.mcg.java.tool.serviceloader.utils.ServiceAnnotation; @ServiceAnnotation(name=&quot;handlerImpl1&quot;) public class HandlerImpl1 implements Handler { public void handler() { System.out.println(&quot;this is handlerImpl1&quot;); } } package com.mcg.java.tool.serviceloader.HandlerImpl; import com.mcg.java.tool.serviceloader.Handler; import com.mcg.java.tool.serviceloader.utils.ServiceAnnotation; @ServiceAnnotation(name=&quot;handlerImpl2&quot;) public class HandlerImpl2 implements Handler { public void handler() { System.out.println(&quot;this is handlerImpl2&quot;); } } //SPI配置文件（META-INF/services/com.mcg.java.tool.serviceloader.Handler） com.mcg.java.tool.serviceloader.HandlerImpl.DefaultHandlerImpl com.mcg.java.tool.serviceloader.HandlerImpl.HandlerImpl1 com.mcg.java.tool.serviceloader.HandlerImpl.HandlerImpl2 //测试: package com.mcg.java.tool.serviceloader; import com.mcg.java.tool.serviceloader.utils.ServicerLoaderUtils; public class ServiceloaderTest { @SuppressWarnings(&quot;unchecked&quot;) public static void main(String[] args) throws Exception { Handler handler=(Handler) ServicerLoaderUtils.getService(&quot;default&quot;,Handler.class); handler.handler(); Handler handler1=(Handler) ServicerLoaderUtils.getService(&quot;handlerImpl1&quot;,Handler.class); handler1.handler(); Handler handler2=(Handler) ServicerLoaderUtils.getService(&quot;handlerImpl2&quot;,Handler.class); handler2.handler(); } } //结果： this is defaultHandler this is handlerImpl1 this is handlerImpl2 在上面的showcase中，ServicerLoaderUtils和ServiceAnnotation是两个工具类，只要基于这两个工具类就可以实现基于名字来获取不同的服务，然后基于策略模式执行相应的服务。ServicerLoaderUtils的load方法中对接ServiceLoader来实现服务的加载。 ServiceLoader的源码分析 上面showcase中先根据ServiceLoader的load静态方法根据目标接口加载出一个ServiceLoader实例，然后可以遍历这个实例（实现了Iterable接口），获取到接口的所有实现类。 ServiceLoader有几个重要属性： //查找实现类的前级目录 private static final String PREFIX = &quot;META-INF/services/&quot;; //要加载的接口 private Class&lt;S&gt; service; // private ClassLoader loader; // 缓存已经加载过的实现类，其中key为实现类的全名 private LinkedHashMap&lt;String,S&gt; providers = new LinkedHashMap&lt;&gt;(); //延迟加载器 private LazyIterator lookupIterator; 在上面调用load方法中，会创建ServiceLoader实例，会初始化的重要属性，此时还没有进行任何接口实现类的加载操作，属于延迟加载类型的。 在执行for循环的时候，由于ServiceLoader实现了Iterable接口，即实现了该接口的iterator()方法，实现内容如下： public Iterator&lt;S&gt; iterator() { return new Iterator&lt;S&gt;() { Iterator&lt;Map.Entry&lt;String,S&gt;&gt; knownProviders = providers.entrySet().iterator(); public boolean hasNext() { if (knownProviders.hasNext()) return true; return lookupIterator.hasNext(); } public S next() { if (knownProviders.hasNext()) return knownProviders.next().getValue(); return lookupIterator.next(); } public void remove() { throw new UnsupportedOperationException(); } }; } 其实for循环就是调用上述hasNext()和next()方法的过程。 第一次循环遍历会使用lookupIterator去查找，之后就缓存到providers中。LazyIterator会去加载类路径下/META-INF/services/接口全称 文件的url地址，使用如下代码来加载： String fullName = PREFIX + service.getName(); if (loader == null) configs = ClassLoader.getSystemResources(fullName); else configs = loader.getResources(fullName); 文件加载并解析完成之后，得到一系列的接口实现类的完整类名，调用next()方法时才回去真正执行接口实现类的加载操作，并根据无参构造器创建出一个实例，存到providers中； 之后再次遍历ServiceLoader，就直接遍历providers中的数据 S p = service.cast(c.newInstance()); providers.put(cn, p); ServiceLoader缺点分析 虽然ServiceLoader也算是使用的延迟加载，但是基本只能通过遍历全部获取，也就是接口的实现类全部加载并实例化一遍。如果你并不想用某些实现类，它也被加载并实例化了，这就造成了浪费。 获取某个实现类的方式不够灵活，只能通过Iterator形式获取，不能根据某个参数来获取对应的实现类","tags":[{"name":"SPI","slug":"SPI","permalink":"https://mcgwinds.github.io/tags/SPI/"}]},{"title":"Annotation","date":"2017-02-19T13:23:35.000Z","path":"2017/02/19/Annotation/","text":"Annotation的注解定义通过关键字@interface表示。定义注解格式： public @interface 注解名 {定义体} 注解参数的可支持数据类型： 1.所有基本数据类型（int,float,boolean,byte,double,char,long,short) 2.String类型 3.Class类型 4.enum类型 5.Annotation类型 6.以上所有类型的数组 下面通过例子来分析注解： //注解类定义 package com.mcg.demo; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) public @interface AnnotationDemo { String fun() default &quot;hello Annotation&quot;; } //注解类使用demo package com.mcg.demo; @AnnotationDemo public class AnnotationMain { public static void main(String[] args) { AnnotationDemo annotationDemo=AnnotationMain.class.getAnnotation(AnnotationDemo.class); String name=annotationDemo.fun(); System.out.println(name); } } //输出： hello Annotation 观察上面使用例子以及输出结果，可以确定AnnotationDemo在编译过程中，编译器对其进行了语法糖处理。通过javap -verbose查看编译后的AnnotationDemo.class文件： public interface com.mcg.demo.AnnotationDemo extends java.lang.annotation.Annotation SourceFile: &quot;AnnotationDemo.java&quot; RuntimeVisibleAnnotations: 0: #14(#15=[e#16.#17]) 1: #18(#15=e#19.#20) minor version: 0 major version: 49 flags: ACC_PUBLIC, ACC_INTERFACE, ACC_ABSTRACT, ACC_ANNOTATION Constant pool: #1 = Class #2 // com/mcg/demo/AnnotationDemo #2 = Utf8 com/mcg/demo/AnnotationDemo #3 = Class #4 // java/lang/Object #4 = Utf8 java/lang/Object #5 = Class #6 // java/lang/annotation/Annotation #6 = Utf8 java/lang/annotation/Annotation #7 = Utf8 fun #8 = Utf8 ()Ljava/lang/String; #9 = Utf8 AnnotationDefault #10 = Utf8 hello Annotation #11 = Utf8 SourceFile #12 = Utf8 AnnotationDemo.java #13 = Utf8 RuntimeVisibleAnnotations #14 = Utf8 Ljava/lang/annotation/Target; #15 = Utf8 value #16 = Utf8 Ljava/lang/annotation/ElementType; #17 = Utf8 TYPE #18 = Utf8 Ljava/lang/annotation/Retention; #19 = Utf8 Ljava/lang/annotation/RetentionPolicy; #20 = Utf8 RUNTIME { public abstract java.lang.String fun(); flags: ACC_PUBLIC, ACC_ABSTRACT AnnotationDefault: default_value: s#10} 发现编译器将AnnotationDemo变成了接口，同时继承了java.lang.annotation.Annotation接口，Annotation接口是所有注解的共同基类接口。由于AnnotationDemo是接口，要调用fun()方法，需要创建出实现了AnnotationDemo的实例。观察使用例子语句： 1.AnnotationDemo annotationDemo=AnnotationMain.class.getAnnotation(AnnotationDemo.class); 2.String name=annotationDemo.fun(); 通过语句2确定语句1返回了一个实现了AnnotationDemo的实例。debug代码可以观察具体的调用堆栈，这里不具体讲解，过程中涉及到了一个重要的栈帧，是AnnotationParser的annotationForMap方法（如下），该方法的作用就是通过动态代理的机制返回一个实现了AnnotationDemo的代理类。所以语句1中annotationDemo就是这个代理类。 //AnnotationParser public static Annotation annotationForMap(Class&lt;? extends Annotation&gt; arg, Map&lt;String, Object&gt; arg0) { return (Annotation) Proxy.newProxyInstance(arg.getClassLoader(), new Class[]{arg}, new AnnotationInvocationHandler(arg, arg0)); } AnnotationInvocationHandler类实现了InvocationHandler接口。 上面AnnotationDemo中设置了一些注解，这些注解是所谓的元注解，元注解的作用就是负责注解其他注解。Java5.0定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。Java5.0定义的元注解： 1.@Target,2.@Retention,3.@Documented,4.@Inherited @Target： @Target说明了Annotation所修饰的对象范围：Annotation可被用于 packages、types（类、接口、枚举、Annotation类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数）。在Annotation类型的声明中使用了target可更加明晰其修饰的目标。 作用：用于描述注解的使用范围（即：被描述的注解可以用在什么地方） 取值(ElementType)有： 1.CONSTRUCTOR:用于描述构造器 2.FIELD:用于描述域 3.LOCAL_VARIABLE:用于描述局部变量 4.METHOD:用于描述方法 5.PACKAGE:用于描述包 6.PARAMETER:用于描述参数 7.TYPE:用于描述类、接口(包括注解类型) 或enum声明 @Retention： @Retention定义了该Annotation被保留的时间长短：某些Annotation仅出现在源代码中，而被编译器丢弃；而另一些却被编译在class文件中；编译在class文件中的Annotation可能会被虚拟机忽略，而另一些在class被装载时将被读取（请注意并不影响class的执行，因为Annotation与class在使用上是被分离的）。使用这个meta-Annotation可以对 Annotation的“生命周期”限制。 作用：表示需要在什么级别保存该注释信息，用于描述注解的生命周期（即：被描述的注解在什么范围内有效） 取值（RetentionPoicy）有： 1.SOURCE:在源文件中有效（即源文件保留） 2.CLASS:在class文件中有效（即class保留） 3.RUNTIME:在运行时有效（即运行时保留） @Documented: @Documented用于描述其它类型的annotation应该被作为被标注的程序成员的公共API，因此可以被例如javadoc此类的工具文档化。Documented是一个标记注解，没有成员。 @Inherited： @Inherited 元注解是一个标记注解，@Inherited阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类。","tags":[{"name":"JAVA基础","slug":"JAVA基础","permalink":"https://mcgwinds.github.io/tags/JAVA基础/"}]},{"title":"Enum","date":"2017-02-12T11:15:37.000Z","path":"2017/02/12/Enum/","text":"Java的枚举定义通过关键字Enum表示。Enum定义类似如下： package com.mcg.demo; public enum EnumDemo { Demo1(&quot;demo1&quot;),Demo2(&quot;demo2&quot;),Demo3(&quot;demo3&quot;); private String name; EnumDemo(String name) { this.name=name; } } 当我们使用EnumDemo类时，发现EnumDemo类默认给我们提供了values、valueOf方法 EnumDemo.values(); EnumDemo.valueOf(&quot;demo1&quot;); EnumDemo.valueOf(EnumDemo.class, &quot;demo1&quot;); 所以应该是编译器在编译源代码的时候，进行了特殊处理。需要分析编译后产生的class文件， public final class com.mcg.demo.EnumDemo extends java.lang.Enum&lt;com.mcg.demo.EnumDemo&gt; { public static final com.mcg.demo.EnumDemo Demo1; public static final com.mcg.demo.EnumDemo Demo2; public static final com.mcg.demo.EnumDemo Demo3; static {Demo1 = new com.mcg.demo.EnumDemo(&quot;Demo1&quot;,0); Demo2 = new com.mcg.demo.EnumDemo(&quot;Demo2&quot;,1); Demo3 = new com.mcg.demo.EnumDemo(&quot;Demo3&quot;,2); $VALUES = (new com.mcg.demo.EnumDemo[] { Demo1, Demo2, Demo3 });} private static final com.mcg.demo.EnumDemo $VALUES[]; private com.mcg.demo.EnumDemo(String s,int i) { super(s, i);} public static com.mcg.demo.EnumDemo[] values() { return (com.mcg.demo.EnumDemo[])$VALUES.clone(); } public static com.mcg.demo.EnumDemo valueOf(String name){ ... } } 短短的几行代码，被编译器处理过之后竟然变得这么多，看来，enmu关键字是java提供给我们的一个语法糖，我们发现，编译器帮我们在编译后默认继承java.lang.Enum类，而不像其他的类一样默认继承Object类。且采用enum声明后，该类会被编译器加上final声明，故该类是无法继承的。Enum是java.lang包中的一个类，Enum类在JDK中是这样描述：(This is the common base class of all Java language enumeration types)Java语言中所有枚举类型的公共基类。 public abstract class Enum&lt;E extends Enum&lt;E&gt;&gt; implements Comparable&lt;E&gt;, Serializable Enum类是一个抽象类，Enum实现了Serializable接口，可以序列化。 Enum实现了Comparable接口，可以进行比较，默认情况下，只有同类型的enum才进行比较（原因见后文），要实现不同类型的enum之间的比较，只能复写compareTo方法。 构造函数Enum是一个抽象类，不能被实例化，但是他有构造函数，从前面我们反编译出来的代码中，我们也发现了Enum的构造函数，在Enum中只有一个保护类型的构造函数： rotected Enum(String name, int ordinal) { this.name = name; this.ordinal = ordinal;//代表顺序，从0开始； } 其他方法 public String toString() { return name; } public final boolean equals(Object other) { return this==other; } public final int hashCode() { return super.hashCode(); } public final int compareTo(E o) { Enum other = (Enum)o; Enum self = this; if (self.getClass() != other.getClass() &amp;&amp; // optimization self.getDeclaringClass() != other.getDeclaringClass()) throw new ClassCastException(); return self.ordinal - other.ordinal; } public final Class&lt;E&gt; getDeclaringClass() { Class clazz = getClass(); Class zuper = clazz.getSuperclass(); return (zuper == Enum.class) ? clazz : zuper; } //valueOf(String name)调用该方法 public static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt; enumType,String name) { T result = enumType.enumConstantDirectory().get(name); if (result != null) return result; if (name == null) throw new NullPointerException(&quot;Name is null&quot;); throw new IllegalArgumentException( &quot;No enum constant &quot; + enumType.getCanonicalName() + &quot;.&quot; + name); }","tags":[{"name":"JAVA基础","slug":"JAVA基础","permalink":"https://mcgwinds.github.io/tags/JAVA基础/"}]},{"title":"AbstractStringBuilder","date":"2017-01-29T02:13:23.000Z","path":"2017/01/29/AbstractStringBuilder/","text":"String是不变字符串，而要实现可变字符串，可以通过继承AbstractStringBuilder类，AbstractStringBuilder是抽象类，实现了Appendable，CharSequence接口，具有append能力，同时也具备了返回字符串长度，返回特定位置字符，返回子串等能力，是StringBuilder和StringBuffer的父类。 类定义: abstract class AbstractStringBuilder implements Appendable, CharSequence 从类定义看，AbstractStringBuilder是包私有。 属性: 私有属性: char value[];（value数组保存字符串，不是final类型） int count; 字符串的长度 方法: AbstractStringBuilder提供了2个构造函数： //默认构造函数。 AbstractStringBuilder() { } //以capacity参数创建保存字符串的数组。 AbstractStringBuilder(int capacity) { value = new char[capacity]; } append()函数系列 public AbstractStringBuilder append(Object obj) public AbstractStringBuilder append(String str) public AbstractStringBuilder append(StringBuffer sb) public AbstractStringBuilder append(CharSequence s) public AbstractStringBuilder append(CharSequence s, int start, int end) public AbstractStringBuilder append(char[] str) public AbstractStringBuilder append(char str[], int offset, int len) public AbstractStringBuilder append(boolean b) public AbstractStringBuilder append(char c) public AbstractStringBuilder append(int i) public AbstractStringBuilder append(long l) public AbstractStringBuilder append(float f) public AbstractStringBuilder append(double d) insert()函数系列 public AbstractStringBuilder insert(int index, char[] str, int offset,int len) public AbstractStringBuilder insert(int offset, Object obj) public AbstractStringBuilder insert(int offset, String str) public AbstractStringBuilder insert(int offset, char[] str) public AbstractStringBuilder insert(int dstOffset, CharSequence s public AbstractStringBuilder insert(int dstOffset, CharSequence s,int start, int end) public AbstractStringBuilder insert(int offset, boolean b) public AbstractStringBuilder insert(int offset, char c) public AbstractStringBuilder insert(int offset, int i) public AbstractStringBuilder insert(int offset, long l) public AbstractStringBuilder insert(int offset, float f) public AbstractStringBuilder insert(int offset, double d) 在append和insert等函数的时候，需要判断进行数组扩容，expandCapacity函数完成数组的扩容，具体处理逻辑如下： void expandCapacity(int minimumCapacity) { //原来数组的两倍+2(为什么这样设置，而不是2倍或其他) int newCapacity = value.length * 2 + 2; if (newCapacity - minimumCapacity &lt; 0) //如果newCapacity小于minimumCapacity，则将扩容大小设置为minimumCapacity newCapacity = minimumCapacity; if (newCapacity &lt; 0) { if (minimumCapacity &lt; 0) // overflow throw new OutOfMemoryError(); newCapacity = Integer.MAX_VALUE; } //调用Arrays.copyOf将value复制到扩容后的数组 value = Arrays.copyOf(value, newCapacity); } public void ensureCapacity(int minimumCapacity) //子类可以调用的方法实现扩容，在方法中调用ensureCapacityInternal private void ensureCapacityInternal(int minimumCapacity) //ensureCapacityInternal调用ensureCapacityInternal 其他方法 public int length() 返回字符串长度 public int capacity() 返回数组大小 public AbstractStringBuilder appendCodePoint(int codePoint) public charAt(int index) 返回字符串中第（index+1）个字符 public AbstractStringBuilder deleteCharAt(int index) public void setLength(int newLength) 设置字符串长度为newLength，如果newLength长度大于count，则以newLength为字符串长度，同时[count,newLengt-1]区间设置字符为&apos;/0&apos;;当newLength长度小于count，则字符串value[0,newLength-1] public void trimToSize() 如果字符串小于数组长度，将数组长度设置为字符串 public int indexOf(String str) //返回str在字符串中的位置 public int lastIndexOf(String str) //返回str在字符串中最后的位置 public AbstractStringBuilder reverse()//反转 final char[] getValue() 返回数组 public String substring(int start, int end) public CharSequence subSequence(int start, int end) public AbstractStringBuilder replace(int start, int end, String str) StringBuilder public final class StringBuilder extends AbstractStringBuilder implements java.io.Serializable, CharSequence 构造函数 public StringBuilder() { super(16);//默认创建数组大小为16 } public StringBuilder(int capacity) public StringBuilder(String str) { super(str.length() + 16); append(str); } public StringBuilder(CharSequence seq) { this(seq.length() + 16); append(seq); } 其他方法覆盖了AbstractStringBuilder中的方法，然后在方法体内调用对应的AbstractStringBuilder方法。 StringBuffer StringBuffer与StringBuilder类似，只是方法用synchronized进行了修饰。","tags":[{"name":"JAVA基础","slug":"JAVA基础","permalink":"https://mcgwinds.github.io/tags/JAVA基础/"}]},{"title":"String","date":"2017-01-22T06:21:45.000Z","path":"2017/01/22/String/","text":"String表示字符串，Java中所有字符串的字面值都是String类的实例。例如”hello world”,在定义之后就不能被改变。 类定义: public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence String类实现了Serializable，Comparable,CharSequence接口。String类是final类，也就是说String类没有子类，为什么将String定义为final类型？我的理解是防止子类通过多态修改字符串。 CharSequence接口 CharSequence接口代表了一个只读的字符串，StringBuffer，StringBuilder也实现了该接口，该接口提供了4个方法： int length();返回字符串长度 char charAt(int index);返回特定位置字符 CharSequence subSequence(int start, int end);返回子串 public String toString(); 属性: 私有属性: private final char value[];（value数组保存字符串，定义为final类型） 方法: String提供了10几种构造函数： //默认构造函数。 public String() { this.value = new char[0]; } //以String参数构造一个新分配的String 对象。 public String(String original) { this.value = original.value; this.hash = original.hash; } //以char数组为参数 public String(char value[]) { this.value = Arrays.copyOf(value, value.length); } 在Java中，String实例中保存有一个char[]字符数组，char[]字符数组是以unicode码来存储的，String 和 char 为内存形式，byte是网络传输或存储的序列化形式。所以在很多传输和存储的过程中需要将byte[]数组和String进行相互转化。所以，String提供了一系列重载的构造方法来将一个字符数组转化成String，提到byte[]和String之间的相互转换就不得不关注编码问题。String(byte[] bytes, Charset charset)是指通过charset来解码指定的byte数组，将其解码成unicode的char[]数组，够造成新的String。 这里的bytes字节流是使用charset进行编码的，想要将他转换成unicode的char[]数组，而又保证不出现乱码，那就要指定其解码方式 String(byte bytes[]) String(byte bytes[], int offset, int length) String(byte bytes[], Charset charset) String(byte bytes[], String charsetName) String(byte bytes[], int offset, int length, Charset charset) 如果我们在使用byte[]构造String的时候，使用的是上面这四种构造方法(带有charsetName或者charset参数)的一种的话，那么就会使用StringCoding.decode方法进行解码，使用的解码的字符集就是我们指定的charsetName或者charset。 我们在使用byte[]构造String的时候，如果没有指明解码使用的字符集的话，那么StringCoding的decode方法首先调用系统的默认编码格式，如果没有指定编码格式则默认使用ISO-8859-1编码格式进行编码操作。主要体现代码如下： static char[] decode(byte[] ba, int off, int len) { String csn = Charset.defaultCharset().name(); try { // use charset name decode() variant which provides caching. return decode(csn, ba, off, len); } catch (UnsupportedEncodingException x) { warnUnsupportedCharset(csn); } try { return decode(&quot;ISO-8859-1&quot;, ba, off, len); } catch (UnsupportedEncodingException x) { // If this code is hit during VM initialization, MessageUtils is // the only way we will be able to get any kind of error message. MessageUtils.err(&quot;ISO-8859-1 charset not available: &quot;+ x.toString()); // If we can not find ISO-8859-1 (a required encoding) then things // are seriously wrong with the installation. System.exit(1); return null; } } getBytes 在创建String的时候，可以使用byte[]数组，将一个字节数组转换成字符串，同样，我们可以将一个字符串转换成字节数组，那么String提供了很多重载的getBytes方法。但是，值得注意的是，在使用这些方法的时候一定要注意编码问题。比如： String s = &quot;你好，世界！&quot;; byte[] bytes = s.getBytes(); 这段代码在不同的平台上运行得到结果是不一样的。由于我们没有指定编码方式，所以在该方法对字符串进行编码的时候就会使用系统的默认编码方式，比如在中文操作系统中可能会使用GBK或者GB2312进行编码，在英文操作系统中有可能使用iso-8859-1进行编码。这样写出来的代码就和机器环境有很强的关联性了，所以，为了避免不必要的麻烦，我们要指定编码方式。如使用以下方式： String s = &quot;你好，世界！&quot;; byte[] bytes = s.getBytes(&quot;utf-8&quot;); 其他方法 length() 返回字符串长度 isEmpty() 返回字符串是否为空 charAt(int index) 返回字符串中第（index+1）个字符 char[] toCharArray() 转化成字符数组 trim() 去掉两端空格 toUpperCase() 转化为大写 toLowerCase() 转化为小写 String concat(String str) //拼接字符串 String replace(char oldChar, char newChar) //将字符串中的oldChar字符换成newChar字符 //以上两个方法都使用了String(char[] value, boolean share)； boolean matches(String regex) //判断字符串是否匹配给定的regex正则表达式 boolean contains(CharSequence s) //判断字符串是否包含字符序列s String[] split(String regex, int limit) 按照字符regex将字符串分成limit份。 String[] split(String regex) boolean equalsIgnoreCase(String anotherString)//比较大小 boolean contentEquals(StringBuffer sb)； boolean contentEquals(CharSequence cs) boolean endsWith(String suffix) //是否以suffix结尾 boolean startsWith(String prefix, int toffset)//是否以prefix开始 int compareTo(String anotherString)； int compareToIgnoreCase(String str)； boolean regionMatches(int toffset, String other, int ooffset,int len) //局部匹配 boolean regionMatches(boolean ignoreCase, int toffset,String other, int ooffset, int len) //局部匹配","tags":[{"name":"JAVA基础","slug":"JAVA基础","permalink":"https://mcgwinds.github.io/tags/JAVA基础/"}]},{"title":"Byte","date":"2017-01-13T13:00:34.000Z","path":"2017/01/13/Byte/","text":"Byte类是基本类型byte的包装类。 类定义: public final class Byte extends Number implements Comparable&lt;Byte&gt; 属性: 私有属性: private final byte value;（value属性就是Byte对象中真正保存int值的） 公共属性: public static final byte MIN_VALUE = -128; public static final byte MAX_VALUE = 127; public static final Class&lt;Byte&gt; TYPE = Class.getPrimitiveClass(&quot;byte&quot;); public static final int SIZE = 8; 方法: Integer提供了两个构造方法： //构造一个新分配的 Byte 对象，它表示指定的 byte 值。 public Byte(byte arg0) { this.value = arg0; } //构造一个新分配的 Byte 对象，它表示 String 参数所指示的 byte 值。 public Byte(String arg0) throws NumberFormatException { this.value = parseByte(arg0, 10); } Byte valueOf(byte arg)方法（effective java第一条准则）: //valueOf方法源码 public static Byte valueOf(byte arg) { return Byte.ByteCache.cache[arg + 128]; } Byte类和Integer一样，调用valueOf方法时，会从缓存中取，不过不同的是Byte类调用valueOf取得都是缓存ByteCache中的值。 private static class ByteCache { static final Byte[] cache = new Byte[256]; static { for (int arg = 0; arg &lt; cache.length; ++arg) { cache[arg] = new Byte((byte) (arg - 128)); } } } 作为Byte类的静态内部类，和Byte类一起加载，加载过程中会创建一个长度为256的数组，同时在静态内部块中初始化。 String转成Byte（byte）的方法: Byte decode(String arg) Byte valueOf(String arg, int arg0) byte parseByte(String arg) byte parseByte(String arg, int arg0) 上述方法都是直接或间接的先将String转化为int类型，例如parseByte(String arg, int arg0)方法首先将String转化为int，然后判断该值是否在[-128，127]之间。 public static byte parseByte(String arg, int arg0) throws NumberFormatException { int arg1 = Integer.parseInt(arg, arg0); if (arg1 &gt;= -128 &amp;&amp; arg1 &lt;= 127) { return (byte) arg1; } else { throw new NumberFormatException(&quot;Value out of range. Value:\\&quot;&quot; + arg + &quot;\\&quot; Radix:&quot; + arg0); } } int转成String的方法: String toString(byte arg) Byte的toString(byte arg)方法调用的是Integer的toString(byte arg，10)方法。 compareTo方法: Byte类实现了Comparable接口，所以Byte对象可以和另外一个Byte对象进行比较。 public int compareTo(Byte arg0) { return compare(this.value, arg0.value); } public static int compare(byte arg, byte arg0) { return arg - arg0; } 代码实现比较简单，就是拿出其中的byte类型的value进行比较。","tags":[{"name":"JAVA基础","slug":"JAVA基础","permalink":"https://mcgwinds.github.io/tags/JAVA基础/"}]},{"title":"Boolean","date":"2017-01-12T13:29:34.000Z","path":"2017/01/12/Boolean/","text":"Boolean类是基本类型boolean的包装类。 类定义: public final class Boolean implements Serializable, Comparable&lt;Boolean&gt; 类的定义与Integer类似，这里就不累赘了。 属性: 私有属性: private final boolean value;（value属性就是Boolean对象中真正保存boolean值的） 当我们使用new Boolean(True)创建一个Boolean对象的时候，就会用以下形式给value赋值 public Boolean(boolean arg0) { this.value = arg0; } 公共属性: //ture对应的Boolean静态常量。 public static final Boolean TRUE = new Boolean(true); //false对应的Boolean静态常量 public static final Boolean FALSE = new Boolean(false); public static final Class&lt;Boolean&gt; TYPE = Class .getPrimitiveClass(&quot;boolean&quot;); 方法: Boolean提供了两个构造方法： //构造一个新分配的 Boolean 对象，它表示指定的 boolean 值。 public Boolean(boolean arg0) { this.value = arg0; } //构造一个新分配的 Boolean 对象，它表示 String 参数所指示的 boolean 值。 public Boolean(String arg0) { this(toBoolean(arg0)); } Boolean valueOf(boolean i)方法: //valueOf方法源码 public static Boolean valueOf(boolean arg) { return arg ? TRUE : FALSE; } 当参数是true时取常量TRUE，当参数是false时取常量FALSE。 String转成Boolean的方法: boolean getBoolean(String arg) boolean toBoolean(String arg) parseBoolean(String arg) Boolean valueOf(String arg) getBoolean: public static boolean getBoolean(String arg) { boolean arg0 = false; try { arg0 = toBoolean(System.getProperty(arg)); } catch (IllegalArgumentException arg2) { ; } catch (NullPointerException arg3) { ; } return arg0; } 确定具有指定名称的系统属性的Boolean值。 toBoolean: private static boolean toBoolean(String arg) { return arg != null &amp;&amp; arg.equalsIgnoreCase(&quot;true&quot;); } 将参数与字符串true进行比较 parseBoolean: public static boolean parseBoolean(String arg) { return toBoolean(arg); } 该方法调用toBoolean，将String转化为boolean。 boolean转成String的方法: String toString(boolean arg) 直接看toString方法，toString方法的定义比较简单，就是把一个boolean类型转换成字符串类型。 public static String toString(boolean arg) { return arg ? &quot;true&quot; : &quot;false&quot;; } compareTo方法: public int compareTo(Boolean arg0) { return compare(this.value, arg0.value); } public static int compare(boolean arg, boolean arg0) { return arg == arg0 ? 0 : (arg ? 1 : -1); } 代码实现比较简单，就是拿出其中的boolean类型的value进行比较。","tags":[{"name":"JAVA基础","slug":"JAVA基础","permalink":"https://mcgwinds.github.io/tags/JAVA基础/"}]},{"title":"Integer","date":"2017-01-11T04:29:34.000Z","path":"2017/01/11/Integer/","text":"Integer类是基本类型int的包装类。 类定义: public final class Integer extends Number implements Comparable&lt;Integer&gt; 从类定义中我们可以知道以下几点： 1、Integer类不能被继承 2、Integer类实现了Comparable接口，所以可以用compareTo进行比较并且Integer对象只能和Integer类型的对象进行比较，不能和其他类型比较（至少调用compareTo方法无法比较）。 3、Integer继承了Number类，所以该类可以调用longValue、floatValue、doubleValue等系列方法返回对应的类型的值。 属性: 私有属性: private final int value;（value属性就是Integer对象中真正保存int值的） 当我们使用new Integer(10)创建一个Integer对象的时候，就会用以下形式给value赋值 public Integer(int value) { this.value = value; } 从value的定义形式中可以看出value被定义成final类型。也就说明，一旦一个Integer对象被初始化之后，就无法再改变value的值。 这里深入讨论一下以下代码的逻辑： public class IntegerTest { public static void main(String[] args) { Integer i = new Integer(10); i = 5; } } 在以上代码中，首先调用构造函数new一个Integer对象，给私有属性value赋值，这时value=10,接下来使用i=5的形式试图改变i的值。 有一点开发经验的同学都知道，这个时候如果使用变量i，那么它的值一定是5，那么i=5这个赋值操作到底做了什么呢？到底是如何改变i的值的呢？是改变了原有对象i中value的值还是重新创建了一个新的Integer对象呢？ 其实上面的代码编译阶段编译器就会把i=5转成i = Integer.valueOf(5)[包装操作];这里先直接给出结论，i=5操作并没有改变使用Integer i = new Integer(10);创建出来的i中的value属性的值。要么是直接返回一个已有对象，要么新建一个对象。这里的具体实现细节在后面讲解valueOf方法的时候给出。公共属性: //值为 （－（2的31次方）） 的常量，它表示 int 类型能够表示的最小值。 public static final int MIN_VALUE = 0x80000000; //值为 （（2的31次方）－1） 的常量，它表示 int 类型能够表示的最大值。 public static final int MAX_VALUE = 0x7fffffff; //表示基本类型 int 的 Class 实例。 public static final Class&lt;Integer&gt; TYPE = (Class&lt;Integer&gt;) Class.getPrimitiveClass(&quot;int&quot;); //用来以二进制补码形式表示 int 值的比特位数。 public static final int SIZE = 32; 方法: Integer提供了两个构造方法： //构造一个新分配的 Integer 对象，它表示指定的 int 值。 public Integer(int value) { this.value = value; } //构造一个新分配的 Integer 对象，它表示 String 参数所指示的 int 值。 public Integer(String s) throws NumberFormatException { this.value = parseInt(s, 10); } Integer valueOf(int i)方法（effective java第一条准则）: //valueOf方法源码 public static Integer valueOf(int i) { if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); } 我们看到了在valueOf方法中有一个if表达式，当i小于IntegerCache中high属性，大于IntegerCache中low属性时，返回IntegerCache中cache数组中与i相关的某个值，从名义上可以看出IntegerCache是Integer的缓存，那么IntegerCache又是怎样实现的呢？ private static class IntegerCache { static final int low = -128; static final int high; static final Integer[] cache; static { int arg = 127; String arg0 = VM .getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;); int arg1; if (arg0 != null) { arg1 = Integer.parseInt(arg0); arg1 = Math.max(arg1, 127); arg = Math.min(arg1, 2147483518); } high = arg; cache = new Integer[high - -128 + 1]; arg1 = -128; for (int arg2 = 0; arg2 &lt; cache.length; ++arg2) { cache[arg2] = new Integer(arg1++); } } } 以上是IntegerCache的源码，IntegerCache有三个属性：low=-128，high（通常=127），cache数组，一个静态代码块。IntegerCache的源码结构可知，当加载Integer类时，因为IntegerCache是静态内部类所以会被加载，同时会执行静态代码块，在静态代码块中给high赋值，同时创建cache数组并赋值，cache数组的长度为(high - low) + 1。 所以valueOf方法的if表达式其实取的是IntegerCache中cache数组的值，这么做的好处就是当i在[low high]范围内，就不用重复创建对象，直接从cache中取。 String转成Integer（int）的方法: Integer getInteger(String nm) Integer getInteger(String nm, int val) Integer getInteger(String nm, Integer val) Integer decode(String nm) Integer valueOf(String s) Integer valueOf(String s, int radix) int parseUnsignedInt(String s) int parseUnsignedInt(String s, int radix) int parseInt(String s) int parseInt(String s, int radix) 以上所有方法都能实现将String类型的值转成Integer(int)类型（如果 String 不包含可解析整数将抛出NumberFormatException） 可以说，所有将String转成Integer的方法都是基于parseInt方法实现的。简单看一下以上部分方法的调用栈。 getInteger(String nm) ---&gt; getInteger(nm, null);---&gt;Integer.decode()---&gt;Integer.valueOf()---&gt;parseInt() getInteger: 确定具有指定名称的系统属性的整数值。 第一个参数被视为系统属性的名称。通过 System.getProperty(java.lang.String) 方法可以访问系统属性。然后，将该属性的字符串值解释为一个整数值，并返回表示该值的 Integer 对象。使用 getProperty 的定义可以找到可能出现的数字格式的详细信息。其中参数nm应该在System的props中可以找到。 decode: public static Integer decode(String nm) throws NumberFormatException 该方法的作用是将 String 解码为 Integer。接受十进制、十六进制和八进制数字。 parseInt: public static int parseInt(String s) throws NumberFormatException { return parseInt(s,10); } public static int parseInt(String s, int radix) throws NumberFormatException 使用第二个参数指定的基数(如果没指定，则按照十进制处理），将字符串参数解析为有符号的整数。如果发生以下任意一种情况，则抛出一个 NumberFormatException 类型的异常： 1.第一个参数为 null 或一个长度为零的字符串。 2.基数小于 Character.MIN_RADIX 或者大于 Character.MAX_RADIX。 3.假如字符串的长度超过 1，那么除了第一个字符可以是减号 ‘-‘ (‘u002D’) 外，字符串中存在任意不是由指定基数的数字表示的字符. 4.字符串表示的值不是 int 类型的值。 总结: 上面列举了很多能够将String转成Integer的方法。那么他们之间有哪些区别，又该如何选择呢？ parseInt方法返回的是基本类型int 其他的方法返回的是Integer valueOf（String）方法会调用valueOf(int)方法。 如果只需要返回一个基本类型，而不需要一个对象，可以直接使用Integert.parseInt(“123”); 如果需要一个对象，那么建议使用valueOf(),因为该方法可以借助缓存带来的好处。 如果和进制有关，那么就是用decode方法。 如果是从系统配置中取值，那么就是用getInteger int转成String的方法: String toString() static String toString(int i) static String toString(int i, int radix) static String toBinaryString(int i) static String toHexString(int i) static String toOctalString(int i) static String toUnsignedString(int i) static String toUnsignedString(int i, int radix) 直接看toString方法，toString方法的定义比较简单，就是把一个int类型的数字转换成字符串类型，但是这个方法的实现调用了一系列方法。 public static String toString(int i) { if (i == Integer.MIN_VALUE) //下面代码要将负数转化为正数 return &quot;-2147483648&quot;; int size = (i &lt; 0) ? stringSize(-i) + 1 : stringSize(i); char[] buf = new char[size]; getChars(i, size, buf); return new String(buf, true); } compareTo方法: Integer类实现了Comparable接口，所以Integer对象可以和另外一个Integer对象进行比较。 public int compareTo(Integer anotherInteger) { return compare(this.value, anotherInteger.value); } public static int compare(int x, int y) { return (x &lt; y) ? -1 : ((x == y) ? 0 : 1); } 代码实现比较简单，就是拿出其中的int类型的value进行比较。 参考资料 http://www.hollischuang.com/archives/1058","tags":[{"name":"JAVA基础","slug":"JAVA基础","permalink":"https://mcgwinds.github.io/tags/JAVA基础/"}]}]