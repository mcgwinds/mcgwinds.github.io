[{"title":"程序员","date":"2017-03-18T15:05:14.000Z","path":"2017/03/18/Programmer/","text":"从最早接触C言语，再到C++，perl，到现在的java，涉及软件世界也有些许年了，编程一直是自己很喜欢的事。工作快两年了,怎样成为程序员,一直在不断地思考、探索？因为在自己心中，程序员职业一直是充满艺术性的，程序员是艺术家（艺术家：具有较高的审美能力和娴熟的创造技巧并从事艺术创作劳动而有一定成就的艺术工作者），是一个源于自然，发于心灵的艺术作品创作者。这世界，程序员太少，码农太多，自己现在也是一个活生生的码农。不知是哪个聪明的人发明的这么恰当的词汇“码农”。不过，很多时候一周能搬几行代码，砌个功能也是一种奢望，因为总有一堆公司琐事在困扰的你。 今天网上看到一篇老外写的文章关于怎样成为程序员，对自己很有指导意义，总结起来分下面5点：1.问题分解： 编程是解决问题，在你开始写任何代码之前，你应该有一套清晰的解决问题的方法论。程序员，能够将问题不断分解为更小部分，直到这些部分可以解决。同时会选出最合适的一种方法，方便实现，方便测试。2.方案分析： 程序员应该具备考虑多种场景的能力。在不同的场景下，结果很有可能南辕北辙。例如：如果参数时null，会发生什么；如这些条件都为true，又会怎样；该方法是否同步，并发场景下又改怎么处理。换句话说，程序员也是测试人员。相反的，码农很有可能考虑的只有一种发生的场景，对不其他场景触发的错误就没有不知道如何去cover。3.命名： 在程序设计中会涉及到大量的命名：类，方法，变量。程序设计的代码其实就是一份文档，通过名字就能大体清楚代码的功能。其实，能合适的命名是困难的，因为需要你清楚的知道每个名字代表的含义。4.连贯性： 连贯性是一个重要的性质。涉及各种变量命名，方法名，模块的分解，目录结构，错误处理，日志记录，文档等等。例如：一些相关变量一起出现在用到它们的时候，当有一个丢失的时候，能帮助你更快的发现。5.学习 作为程序员，你需要不断地学习。在增加一个新的特征的时候，你需要明白背后含义。当增加一段代码到程序中，应该知道放何处，怎么放是合适的。同时深入理解开发的程序，能够正确的处理。当你有较强的学习能力的时候，将会成为有效的开发者。程序的世界知识，框架，技术更新很快，信息量又巨大。你应该具有辨别什么是好的，什么是不好的能力。 路漫漫其修远兮 吾将上下而求索 愿自己早日成为程序员。","tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://mcgwinds.github.io/tags/杂谈/"}]},{"title":"RPC框架","date":"2017-03-12T12:39:14.000Z","path":"2017/03/12/rpc/","text":"分布式服务框架：用于实现服务复用，由一个RPC框架，注册中心，监控中心组成。大体会部署在应用层和数据层之间。其中RPC框架是最重要的部分，由服务端和客户端两部分组成，服务端暴露服务，会将服务信息注册到注册中心，客户端调用服务，会从注册中心获取服务信息，然后与服务端进行交互。实现一个高并发、高可用、高性能的的RPC框架涉及很多技术点。 下面是一个简单的RPC框架showcase，没有涉及注册中心，监控中心，服务端启动通过export方法暴露服务，客户端启动通过refer方法引用服务。 //暴露服务： package com.mcg.rpc.server; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Method; import java.net.ServerSocket; import java.net.Socket; public class Provider { public static void export(final Object instance, int port) throws Exception { if(instance==null) throw new IllegalArgumentException(&quot;service is null&quot;); if (port &gt; 65535) throw new IllegalArgumentException(port + &quot;is invalid&quot;); ServerSocket serverSocket = new ServerSocket(port); for(;;) { try { final Socket socket = serverSocket.accept(); new Thread(new Runnable() { public void run() { try { try { ObjectInputStream objectInputStream = new ObjectInputStream(socket.getInputStream()); try { String methodName = objectInputStream.readUTF(); Class&lt;?&gt;[] parameterTypes = (Class&lt;?&gt;[])objectInputStream.readObject(); Object[] arguments = (Object[])objectInputStream.readObject(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(socket.getOutputStream()); try { Method method = instance.getClass().getMethod(methodName, parameterTypes); Object result = method.invoke(instance, arguments); objectOutputStream.writeObject(result); } catch (Throwable t) { objectOutputStream.writeObject(t); } finally { objectOutputStream.close(); } } finally { objectInputStream.close(); } } finally { socket.close(); } } catch (Exception e) { e.printStackTrace(); } } }).start(); } catch (Exception e) { e.printStackTrace(); } } } } //引用服务： package com.mcg.rpc.client; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; import java.net.Socket; public class Consumer { @SuppressWarnings(&quot;unchecked&quot;) public static &lt;T&gt; T refer(final Class&lt;T&gt; serviceInterface,final String host,final int port) { return (T)Proxy.newProxyInstance(serviceInterface.getClassLoader(),new Class&lt;?&gt;[]{serviceInterface}, new InvocationHandler() { public Object invoke(Object proxy, Method method, Object[] arguments) throws Throwable { Socket socket = new Socket(host, port); try { ObjectOutputStream output = new ObjectOutputStream(socket.getOutputStream()); try { output.writeUTF(method.getName()); output.writeObject(method.getParameterTypes()); output.writeObject(arguments); ObjectInputStream input = new ObjectInputStream(socket.getInputStream()); try { Object result = input.readObject(); if (result instanceof Throwable) { throw (Throwable) result; } return result; } finally { input.close(); } } finally { output.close(); } } finally { socket.close(); } } }); } } //服务接口： package com.mcg.rpc.service; public interface HelloService { void say(String name); } //服务实现： package com.mcg.rpc.service; public class HelloServiceImpl implements HelloService { public void say(String name) { System.out.println(&quot;hello:&quot; + name); } } //测试: package com.mcg.rpc.server; import com.mcg.rpc.service.HelloService; import com.mcg.rpc.service.HelloServiceImpl; public class ServerTest { private final static int PORT=1234; public static void main(String args []) throws Exception { HelloService instance=new HelloServiceImpl(); Provider.export(instance, PORT); } } package com.mcg.rpc.client; import com.mcg.rpc.service.HelloService; public class ClientTest { private final static int PORT=1234; private final static String HOST=&quot;127.0.0.1&quot;; public static void main(String args []) { HelloService helloService=Consumer.refer(HelloService.class, HOST, PORT); helloService.say(&quot;mcg&quot;); } } //结果： hello:mcg","tags":[{"name":"RPC","slug":"RPC","permalink":"https://mcgwinds.github.io/tags/RPC/"}]},{"title":"dubbo(1)->Serviceloader","date":"2017-03-12T12:39:14.000Z","path":"2017/03/12/serviceloader/","text":"中间件技术一直都是自己最感兴趣，有分布式服务框架，分布式消息队列，分布式缓存，分布式数据服务等等，参与开发其中任一一个项目都会学到很多知识，很幸运在开始参加工作后的第一个项目就是分布式服务框架，后来接触到了dubbo，被dubbo的设计所吸引，虽然有时间偶尔也会看看dubbo的代码，但没有系统的好好总结沉淀下来，看得如同过往云烟，时间也就那样的流逝了。最近也不断地在反思，工作快2两年了，像是一直在原地踏步，很多时候都是急于求成，自知其然，却不知其所以然，看着距离自己的第一个目标还那么的远，所以决定好好的静下心来先从学dubbo开始。 dubbo是服务框架，服务框架是用于实现服务的复用的框架，是软件框架。那框架是什么？让我联想到了建筑框架，建筑框架确定了整个建筑的结构，建筑框架允许你在不改变结构的基础上，自由改变其内容。例如，你可以用墙体随意分隔房间。所以框架就好比建筑框架，可以这样说，框架的本质就是“扩展”。在一个框架中，实现丰富的功能固然重要，然而更重要的是：建立良好的扩展机制。 dubbo基于JDK中的SPI机制扩展了一套自己的扩展机制，让使用者方便地自己扩展和实现自己的插件。下面介绍JDK提供的SPI机制(java.util.ServiceLoader)： SPI英文为Service Provider Interface单从字面可以理解为Service提供者接口，正如从SPI的名字去理解SPI就是Service提供者接口；提供给服务提供厂商与扩展框架功能的开发者使用的接口。 SPI 机制的约定： 1) 在META-INF/services/目录中创建以接口全限定名命名的文件该文件内容为Api具体实现类的全限定名 2) 使用ServiceLoader类动态加载META-INF中的实现类 3) 如SPI的实现类为Jar则需要放在主程序classPath中 4) Api具体实现类必须有一个不带参数的构造方法 下面是基于JDK的SPI的showcase //工具类(对接用户和SPI)： package com.mcg.java.tool.serviceloader.utils; import java.util.ServiceLoader; import java.util.concurrent.ConcurrentHashMap; import java.util.concurrent.ConcurrentMap; //工具类 public class ServicerLoaderUtils { //保存spi加载的服务 private static ConcurrentMap&lt;String,Object&gt; services=new ConcurrentHashMap&lt;String,Object&gt;(); //用户调用方法,获取相应的服务 public static Object getService(String name,Class&lt;?&gt; clazz) throws Exception { Object service= services.get(name); if(null==service) { load(clazz); service= services.get(name); } return service; } //加载服务 public static &lt;T&gt; void load(Class&lt;T&gt; service) throws Exception { for (T t:ServiceLoader.load(service)) { String name=t.getClass().getAnnotation(ServiceAnnotation.class).name(); services.putIfAbsent(name, t); } } } //注解工具类： package com.mcg.java.tool.serviceloader.utils; import java.lang.annotation.Documented; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Documented @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) public @interface ServiceAnnotation { String name() default &quot;default&quot;; } //服务接口： package com.mcg.java.tool.serviceloader; public interface Handler { void handler(); } //服务实现： package com.mcg.java.tool.serviceloader.HandlerImpl; import com.mcg.java.tool.serviceloader.Handler; import com.mcg.java.tool.serviceloader.utils.ServiceAnnotation; @ServiceAnnotation public class DefaultHandlerImpl implements Handler { public void handler() { System.out.println(&quot;this is defaultHandler&quot;); } } package com.mcg.java.tool.serviceloader.HandlerImpl; import com.mcg.java.tool.serviceloader.Handler; import com.mcg.java.tool.serviceloader.utils.ServiceAnnotation; @ServiceAnnotation(name=&quot;handlerImpl1&quot;) public class HandlerImpl1 implements Handler { public void handler() { System.out.println(&quot;this is handlerImpl1&quot;); } } package com.mcg.java.tool.serviceloader.HandlerImpl; import com.mcg.java.tool.serviceloader.Handler; import com.mcg.java.tool.serviceloader.utils.ServiceAnnotation; @ServiceAnnotation(name=&quot;handlerImpl2&quot;) public class HandlerImpl2 implements Handler { public void handler() { System.out.println(&quot;this is handlerImpl2&quot;); } } //SPI配置文件（META-INF/services/com.mcg.java.tool.serviceloader.Handler） com.mcg.java.tool.serviceloader.HandlerImpl.DefaultHandlerImpl com.mcg.java.tool.serviceloader.HandlerImpl.HandlerImpl1 com.mcg.java.tool.serviceloader.HandlerImpl.HandlerImpl2 //测试: package com.mcg.java.tool.serviceloader; import com.mcg.java.tool.serviceloader.utils.ServicerLoaderUtils; public class ServiceloaderTest { @SuppressWarnings(&quot;unchecked&quot;) public static void main(String[] args) throws Exception { Handler handler=(Handler) ServicerLoaderUtils.getService(&quot;default&quot;,Handler.class); handler.handler(); Handler handler1=(Handler) ServicerLoaderUtils.getService(&quot;handlerImpl1&quot;,Handler.class); handler1.handler(); Handler handler2=(Handler) ServicerLoaderUtils.getService(&quot;handlerImpl2&quot;,Handler.class); handler2.handler(); } } //结果： this is defaultHandler this is handlerImpl1 this is handlerImpl2 在上面的showcase中，ServicerLoaderUtils和ServiceAnnotation是两个工具类，只要基于这两个工具类就可以实现基于名字来获取不同的服务，然后基于策略模式执行相应的服务。ServicerLoaderUtils的load方法中对接ServiceLoader来实现服务的加载。 ServiceLoader的源码分析 上面showcase中先根据ServiceLoader的load静态方法根据目标接口加载出一个ServiceLoader实例，然后可以遍历这个实例（实现了Iterable接口），获取到接口的所有实现类。 ServiceLoader有几个重要属性： //查找实现类的前级目录 private static final String PREFIX = &quot;META-INF/services/&quot;; //要加载的接口 private Class&lt;S&gt; service; // private ClassLoader loader; // 缓存已经加载过的实现类，其中key为实现类的全名 private LinkedHashMap&lt;String,S&gt; providers = new LinkedHashMap&lt;&gt;(); //延迟加载器 private LazyIterator lookupIterator; 在上面调用load方法中，会创建ServiceLoader实例，会初始化的重要属性，此时还没有进行任何接口实现类的加载操作，属于延迟加载类型的。 在执行for循环的时候，由于ServiceLoader实现了Iterable接口，即实现了该接口的iterator()方法，实现内容如下： public Iterator&lt;S&gt; iterator() { return new Iterator&lt;S&gt;() { Iterator&lt;Map.Entry&lt;String,S&gt;&gt; knownProviders = providers.entrySet().iterator(); public boolean hasNext() { if (knownProviders.hasNext()) return true; return lookupIterator.hasNext(); } public S next() { if (knownProviders.hasNext()) return knownProviders.next().getValue(); return lookupIterator.next(); } public void remove() { throw new UnsupportedOperationException(); } }; } 其实for循环就是调用上述hasNext()和next()方法的过程。 第一次循环遍历会使用lookupIterator去查找，之后就缓存到providers中。LazyIterator会去加载类路径下/META-INF/services/接口全称 文件的url地址，使用如下代码来加载： String fullName = PREFIX + service.getName(); if (loader == null) configs = ClassLoader.getSystemResources(fullName); else configs = loader.getResources(fullName); 文件加载并解析完成之后，得到一系列的接口实现类的完整类名，调用next()方法时才回去真正执行接口实现类的加载操作，并根据无参构造器创建出一个实例，存到providers中； 之后再次遍历ServiceLoader，就直接遍历providers中的数据 S p = service.cast(c.newInstance()); providers.put(cn, p); ServiceLoader缺点分析 虽然ServiceLoader也算是使用的延迟加载，但是基本只能通过遍历全部获取，也就是接口的实现类全部加载并实例化一遍。如果你并不想用某些实现类，它也被加载并实例化了，这就造成了浪费。 获取某个实现类的方式不够灵活，只能通过Iterator形式获取，不能根据某个参数来获取对应的实现类","tags":[{"name":"SPI","slug":"SPI","permalink":"https://mcgwinds.github.io/tags/SPI/"}]}]