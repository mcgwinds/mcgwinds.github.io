<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="https://mcgwinds.github.io">
  <title>种一颗树最好的是十年以前，其次是现在</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="记录生活点滴">
<meta property="og:type" content="website">
<meta property="og:title" content="种一颗树最好的是十年以前，其次是现在">
<meta property="og:url" content="https://mcgwinds.github.io/index.html">
<meta property="og:site_name" content="种一颗树最好的是十年以前，其次是现在">
<meta property="og:description" content="记录生活点滴">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="种一颗树最好的是十年以前，其次是现在">
<meta name="twitter:description" content="记录生活点滴">
  
    <link rel="alternative" href="/index.html" title="种一颗树最好的是十年以前，其次是现在" type="application/atom+xml">
  
  
    <link rel="icon" href="/assets/img/favicon.ico">
  
  <link rel="stylesheet" type="text/css" href="/./main.4a524f.css">
  <style type="text/css">
  
    #container.show {
      background: linear-gradient(200deg,#a0cfe4,#e8c37e);
    }
  </style>
  

  
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?a30844fa2bcbce0a9e001fe06cefeddf";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


</head>

<body>
  <div id="container" q-class="show:isCtnShow">
    <canvas id="anm-canvas" class="anm-canvas"></canvas>
    <div class="left-col" q-class="show:isShow">
      
<div class="overlay" style="background: #4d4d4d"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			<img src="/avatar/1.jpg" class="js-avatar">
		</a>
		<hgroup>
		  <h1 class="header-author"><a href="/">mcg</a></h1>
		</hgroup>
		
		<p class="header-subtitle">一天进步一点</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="/archives">所有文章</a></li>
	        
				<li><a href="/photos">相册</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
    		
    			
    			<a q-on="click: openSlider(e, 'innerArchive')" href="javascript:void(0)">所有文章</a>
    			
            
    			
            
    			
    			<a q-on="click: openSlider(e, 'aboutme')" href="javascript:void(0)">关于我</a>
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/mcgwinds" title="github"><i class="icon-github"></i></a>
		        
					<a class="weibo" target="_blank" href="http://weibo.com/1902948803" title="weibo"><i class="icon-weibo"></i></a>
		        
					<a class="rss" target="_blank" href="/index.html" title="rss"><i class="icon-rss"></i></a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col" q-class="show:isShow,hide:isShow|isFalse">
      
<nav id="mobile-nav">
  	<div class="overlay js-overlay" style="background: #4d4d4d"></div>
	<div class="btnctn js-mobile-btnctn">
  		<div class="slider-trigger list" q-on="click: openSlider(e)"><i class="icon icon-sort"></i></div>
	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img src="/avatar/1.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author js-header-author">mcg</h1>
			</hgroup>
			
			<p class="header-subtitle"><i class="icon icon-quo-left"></i>一天进步一点<i class="icon icon-quo-right"></i></p>
			
			
			
				
			
				
			
				
			
			
			
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/mcgwinds" title="github"><i class="icon-github"></i></a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/1902948803" title="weibo"><i class="icon-weibo"></i></a>
			        
						<a class="rss" target="_blank" href="/index.html" title="rss"><i class="icon-rss"></i></a>
			        
				</div>
			</nav>

			<nav class="header-menu js-header-menu">
				<ul style="width: 70%">
				
				
					<li style="width: 33.333333333333336%"><a href="/">主页</a></li>
		        
					<li style="width: 33.333333333333336%"><a href="/archives">所有文章</a></li>
		        
					<li style="width: 33.333333333333336%"><a href="/photos">相册</a></li>
		        
				</ul>
			</nav>
		</header>				
	</div>
	<div class="mobile-mask" style="display:none" q-show="isShow"></div>
</nav>

      <div id="wrapper" class="body-wrap">
        <div class="menu-l">
          <div class="canvas-wrap">
            <canvas data-colors="#eaeaea" data-sectionHeight="100" data-contentId="js-content" id="myCanvas1" class="anm-canvas"></canvas>
          </div>
          <div id="js-content" class="content-ll">
            
  
    <article id="post-ExtensionLoader" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/09/ExtensionLoader/">dubbo(2)-&gt;Comma</a>
    </h1>
  

        
        <a href="/2017/07/09/ExtensionLoader/" class="archive-article-date">
  	<time datetime="2017-07-09T02:12:18.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2017-07-09</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>前一篇文章总结了一下JDK的SPI机制，dubbo基于SPI基础上扩展了一套自己的SPI机制，通过ExtensionLoader类实现。第一次看ExtensionLoader源码，一脸懵逼，debug几次还是云里雾里。后来通过网上查资料，看到了Cooma（<a href="https://github.com/alibaba/cooma/wiki），而Cooma的来源就是dubbo项目中的SPI。Cooma是一个独立的Java微容器，所以打算先从它讲起，后面的文章再分析dubbo框架中是如何运用ExtensionLoader的。" target="_blank" rel="external">https://github.com/alibaba/cooma/wiki），而Cooma的来源就是dubbo项目中的SPI。Cooma是一个独立的Java微容器，所以打算先从它讲起，后面的文章再分析dubbo框架中是如何运用ExtensionLoader的。</a></p>
<p>Comma，官方介绍的已经非常详细了，这里大体说一下几个特点：</p>
<p>1）以插件方式加载扩展（SPI）</p>
<p>2）支持依赖扩展点的自动加载（IOC）</p>
<p>3 可以有扩展点Wrapper，为扩展写公共Filter代码（AOP）</p>
<p>下面通过分析Comma源码来了解Comma是这几大特点，Comma的代码主要两个类Extension(把一个接口标识成扩展点)，ExtensionLoader(加载和管理扩展)。</p>
<p>Extension：是一个注解，通过Extension注解将一个接口标识成扩展点。</p>
<pre><code>@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE})
public @interface Extension {

/**
 * the default extension name.
 *
 * @since 0.1.0
 */
String value() default &quot;&quot;;

 }
</code></pre><p>ExtensionLoader：ExtensionLoader类应该说是Comma的核心，通过它实现扩展点（SPI）的加载，扩展点（IOC）的依赖注入，扩展点（AOP）的包装。</p>
<p>属性：<br>加载相关属性：</p>
<pre><code>//扩展点的加载相对路径（对应JDk SPI的扩展点加载路径&quot;META-INF/service/&quot;）
private static final String EXTENSION_CONF_DIRECTORY = &quot;META-INF/extensions/&quot;; 

//适配类key标识（对应dubbo中的Adaptive注解）
private static final String PREFIX_ADAPTIVE_CLASS = &quot;*&quot;;

//包装类key标识（对应dubbo中的cachedWrapperClasses）
//private static final String PREFIX_WRAPPER_CLASS = &quot;+&quot;;

//名字分隔
private static final Pattern NAME_SEPARATOR = Pattern.compile(&quot;\\s*,+\\s*&quot;);

//名字校验
private static final Pattern NAME_PATTERN = Pattern.compile(&quot;[a-zA-Z0-9_]+&quot;);

//类型与ExtensionLoader的映射，通过类型取对应的ExtensionLoader
private static final ConcurrentMap&lt;Class&lt;?&gt;, ExtensionLoader&lt;?&gt;&gt; EXTENSION_LOADERS = new ConcurrentHashMap&lt;Class&lt;?&gt;, ExtensionLoader&lt;?&gt;&gt;();
</code></pre><p>扩展点相关属性</p>
<pre><code>private final Class&lt;T&gt; type;
//默认扩展点
private final String defaultExtension;

private final Holder&lt;Map&lt;String, Class&lt;?&gt;&gt;&gt; extClassesHolder = new Holder&lt;Map&lt;String, Class&lt;?&gt;&gt;&gt;();
private volatile Map&lt;String, Map&lt;String, String&gt;&gt; name2Attributes;
private final ConcurrentMap&lt;Class&lt;?&gt;, String&gt; extClass2Name = new ConcurrentHashMap&lt;Class&lt;?&gt;, String&gt;();

//适配类，适配类唯一
private volatile Class&lt;?&gt; adaptiveClass = null;
//包装类映射关系
private volatile Map&lt;String, Class&lt;? extends T&gt;&gt; name2Wrapper;
</code></pre><p>方法：</p>
<pre><code>//私有构造函数
private ExtensionLoader(Class&lt;T&gt; type)
</code></pre><p>设置ExtensionLoader的type属性，type属性用于获取type对应的所有扩展点，以及默认扩展点属性defaultExtension。</p>
<pre><code>//获取类对应的ExtensionLoader
public static &lt;T&gt; ExtensionLoader&lt;T&gt; getExtensionLoader(Class&lt;T&gt; type)
</code></pre><p>因为ExtensionLoader是私有的，所以只能通过该方法获取类对应的ExtensionLoader，该方法首先判断type是否为null，若为null则抛出参数异常，是否是接口，若不为接口则抛出参数异常，判断接口是否有Extension注解标识，若没有抛出参数一样。如果上述条件都通过，则根据类型到EXTENSION_LOADERS中取对应的EXTENSION_LOADERS，若为null，则新建一个ExtensionLoader，将类型作为key，ExtensionLoader为value放入map中。</p>
<p>获取扩展点：</p>
<pre><code>public T getExtension(String name)
public T getExtension(String name, Map&lt;String, String&gt; properties)
public T getExtension(Map&lt;String, String&gt; properties)
public T getExtension(String name, List&lt;String&gt; wrappers)
public T getExtension(String name, Map&lt;String, String&gt; properties, List&lt;String&gt; wrappers)
</code></pre><p>name：扩展点对应的标识，通过类获取对应的扩展点，例如：</p>
<pre><code>impl1=com.alibaba.cooma.ext2.impl.Ext2Impl
</code></pre><p>通过name的impl1，可以获取Ext2Impl。<br>properties：用于扩展点的依赖注入属性值<br>wrappers：根据wrappers中的值从name2Wrapper中获取包装类。</p>
<p>getExtension扩展点的获取执行逻辑：1.createExtension获取扩展点然后实例化扩展点;2.inject依赖注入扩展点;若有包装类则对扩展类执行包装操作createWrapper;</p>
<p>获取扩展点然后实例化扩展点:</p>
<pre><code>createExtension——&gt;getExtensionClass——&gt;getExtensionClasses——&gt;loadExtensionClasses0——&gt;readExtension0
</code></pre><p>createExtension:执行getExtensionClass操作，获取扩展点class，然后实例化。</p>
<p>getExtensionClass：执行getExtensionClasses()操作，返回对应的extClassesHolder map，然后根据参数name，获取对应的扩展点class。</p>
<p>getExtensionClasses：判断extClassesHolder中是否有值，没有调用loadExtensionClasses0进行加载。</p>
<p>loadExtensionClasses0：根据fileName = EXTENSION_CONF_DIRECTORY + type.getName()[META-INF/extensions/{type}],获取文件，调用readExtension0获取文件内容。</p>
<p>readExtension0：按行读取文件内容，如果name以PREFIX_ADAPTIVE_CLASS，这该扩展点是一个适配类，若以PREFIX_WRAPPER_CLASS开头，则该类是一个包装类，判断构造函数是否正确。若既不是适配类，也不是包装类，则判断是否有默认构造函数。</p>
<p>依赖注入：</p>
<p>private T inject(T instance, Map<string, string=""> properties)</string,></p>
<p>遍历扩展点实例的所有方法，方法名以set开头，参数个数为1，方法是public方法，若属性也是一个扩展点，则获取扩展点，然后通过反射进行依赖注入。</p>
<p>扩展点的包装：</p>
<pre><code>private T createWrapper(T instance, Map&lt;String, String&gt; properties, List&lt;String&gt; wrappers)
</code></pre><p>遍历wrappers，取出对应的包装类，包装类也是一个扩展点，它的职责就是对具体的扩展点进行能力增强。得到包装类以后，获取包含参数为扩展的构造函数，然后进行依赖注入。</p>
<p>获取默认的扩展点：</p>
<pre><code>public T getDefaultExtension()
public T getDefaultExtension(List&lt;String&gt; wrappers)
</code></pre><p>以参数defaultExtension调用getExtension获取扩展点。</p>
<p>通过上面的分析，其实使用comma很容易，首先建立接口，然后在接口上注@Extension(“”)注解，基于该接口新建扩展点，在META-INF/extensions/{type}下书写扩展点，调用getExtensionLoader获得ExtensionLoader，通过获得的ExtensionLoader的getExtension方法获取扩展点实例。</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color1">Comma</a>
        		</li>
      		
		</ul>
	</div>

      
	<div class="article-category tagcloud">
		<i class="icon-book icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="/categories/日志/" class="article-tag-list-link color3">日志</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="/categories/dubbo/" class="article-tag-list-link color1">dubbo</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="/categories/Comma/" class="article-tag-list-link color1">Comma</a>
        		</li>
      		
		</ul>
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/2017/07/09/ExtensionLoader/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-Programmer" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/18/Programmer/">程序员</a>
    </h1>
  

        
        <a href="/2017/03/18/Programmer/" class="archive-article-date">
  	<time datetime="2017-03-18T15:05:14.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2017-03-18</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>  从最早接触C言语，再到C++，perl，到现在的java，涉及软件世界也有些许年了，编程一直是自己很喜欢的事。工作快两年了,怎样成为程序员,一直在不断地思考、探索？因为在自己心中，程序员职业一直是充满艺术性的，程序员是艺术家（艺术家：具有较高的审美能力和娴熟的创造技巧并从事艺术创作劳动而有一定成就的艺术工作者），是一个源于自然，发于心灵的艺术作品创作者。这世界，程序员太少，码农太多，自己现在也是一个活生生的码农。不知是哪个聪明的人发明的这么恰当的词汇“码农”。不过，很多时候一周能搬几行代码，砌个功能也是一种奢望，因为总有一堆公司琐事在困扰的你。</p>
<p>今天网上看到一篇老外写的文章关于怎样成为程序员，对自己很有指导意义，总结起来分下面5点：<br>1.问题分解：<br>  编程是解决问题，在你开始写任何代码之前，你应该有一套清晰的解决问题的方法论。程序员，能够将问题不断分解为更小部分，直到这些部分可以解决。同时会选出最合适的一种方法，方便实现，方便测试。<br>2.方案分析：<br>  程序员应该具备考虑多种场景的能力。在不同的场景下，结果很有可能南辕北辙。例如：如果参数时null，会发生什么；如这些条件都为true，又会怎样；该方法是否同步，并发场景下又改怎么处理。换句话说，程序员也是测试人员。相反的，码农很有可能考虑的只有一种发生的场景，对不其他场景触发的错误就没有不知道如何去cover。<br>3.命名：<br>  在程序设计中会涉及到大量的命名：类，方法，变量。程序设计的代码其实就是一份文档，通过名字就能大体清楚代码的功能。其实，能合适的命名是困难的，因为需要你清楚的知道每个名字代表的含义。<br>4.连贯性：<br>  连贯性是一个重要的性质。涉及各种变量命名，方法名，模块的分解，目录结构，错误处理，日志记录，文档等等。例如：一些相关变量一起出现在用到它们的时候，当有一个丢失的时候，能帮助你更快的发现。<br>5.学习<br>  作为程序员，你需要不断地学习。在增加一个新的特征的时候，你需要明白背后含义。当增加一段代码到程序中，应该知道放何处，怎么放是合适的。同时深入理解开发的程序，能够正确的处理。当你有较强的学习能力的时候，将会成为有效的开发者。程序的世界知识，框架，技术更新很快，信息量又巨大。你应该具有辨别什么是好的，什么是不好的能力。</p>
<p>路漫漫其修远兮 吾将上下而求索 愿自己早日成为程序员。</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color3">杂谈</a>
        		</li>
      		
		</ul>
	</div>

      
	<div class="article-category tagcloud">
		<i class="icon-book icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="/categories/日志/" class="article-tag-list-link color3">日志</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="/categories/思索/" class="article-tag-list-link color3">思索</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="/categories/程序员/" class="article-tag-list-link color4">程序员</a>
        		</li>
      		
		</ul>
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/2017/03/18/Programmer/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-serviceloader" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/12/serviceloader/">dubbo(1)-&gt;Serviceloader</a>
    </h1>
  

        
        <a href="/2017/03/12/serviceloader/" class="archive-article-date">
  	<time datetime="2017-03-12T12:39:14.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2017-03-12</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>中间件技术一直都是自己最感兴趣，有分布式服务框架，分布式消息队列，分布式缓存，分布式数据服务等等，参与开发其中任一一个项目都会学到很多知识，很幸运在开始参加工作后的第一个项目就是分布式服务框架，后来接触到了dubbo，被dubbo的设计所吸引，虽然有时间偶尔也会看看dubbo的代码，但没有系统的好好总结沉淀下来，看得如同过往云烟，时间也就那样的流逝了。最近也不断地在反思，工作快2两年了，像是一直在原地踏步，很多时候都是急于求成，自知其然，却不知其所以然，看着距离自己的第一个目标还那么的远，所以决定好好的静下心来先从学dubbo开始。</p>
<p>dubbo是服务框架，服务框架是用于实现服务的复用的框架，是软件框架。那框架是什么？让我联想到了建筑框架，建筑框架确定了整个建筑的结构，建筑框架允许你在不改变结构的基础上，自由改变其内容。例如，你可以用墙体随意分隔房间。所以框架就好比建筑框架，可以这样说，框架的本质就是“扩展”。在一个框架中，实现丰富的功能固然重要，然而更重要的是：建立良好的扩展机制。</p>
<p>dubbo基于JDK中的SPI机制扩展了一套自己的扩展机制，让使用者方便地自己扩展和实现自己的插件。<br>下面介绍JDK提供的SPI机制(java.util.ServiceLoader)：</p>
<p>SPI英文为Service Provider Interface单从字面可以理解为Service提供者接口，正如从SPI的名字去理解SPI就是Service提供者接口；提供给服务提供厂商与扩展框架功能的开发者使用的接口。</p>
<p>SPI 机制的约定：</p>
<p>1) 在META-INF/services/目录中创建以接口全限定名命名的文件该文件内容为Api具体实现类的全限定名</p>
<p>2) 使用ServiceLoader类动态加载META-INF中的实现类</p>
<p>3) 如SPI的实现类为Jar则需要放在主程序classPath中</p>
<p>4) Api具体实现类必须有一个不带参数的构造方法</p>
<p>下面是基于JDK的SPI的showcase</p>
<p>//工具类(对接用户和SPI)：</p>
<pre><code>package com.mcg.java.tool.serviceloader.utils;

import java.util.ServiceLoader;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

//工具类
public class ServicerLoaderUtils
{   
//保存spi加载的服务
private static ConcurrentMap&lt;String,Object&gt; services=new ConcurrentHashMap&lt;String,Object&gt;();

//用户调用方法,获取相应的服务
public static Object getService(String name,Class&lt;?&gt; clazz) throws Exception
{
    Object service= services.get(name);
    if(null==service)
    {   
        load(clazz);
        service= services.get(name);

    }
    return service;
}

//加载服务
public static &lt;T&gt; void load(Class&lt;T&gt; service) throws Exception
{

    for (T t:ServiceLoader.load(service))
    {
        String name=t.getClass().getAnnotation(ServiceAnnotation.class).name();
        services.putIfAbsent(name, t);
    }

}

}
</code></pre><p>//注解工具类：</p>
<pre><code>package com.mcg.java.tool.serviceloader.utils;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Documented
@Target(ElementType.TYPE)  
@Retention(RetentionPolicy.RUNTIME) 
public @interface ServiceAnnotation 
{
  String name() default &quot;default&quot;;
}
</code></pre><p>//服务接口：</p>
<pre><code>package com.mcg.java.tool.serviceloader;

public interface Handler 
{
  void handler();
}
</code></pre><p>//服务实现：</p>
<pre><code>package com.mcg.java.tool.serviceloader.HandlerImpl;

import com.mcg.java.tool.serviceloader.Handler;
import com.mcg.java.tool.serviceloader.utils.ServiceAnnotation;

@ServiceAnnotation
public class DefaultHandlerImpl implements Handler 
{

public void handler()
{
    System.out.println(&quot;this is defaultHandler&quot;);
}

}

package com.mcg.java.tool.serviceloader.HandlerImpl;

import com.mcg.java.tool.serviceloader.Handler;
import com.mcg.java.tool.serviceloader.utils.ServiceAnnotation;

@ServiceAnnotation(name=&quot;handlerImpl1&quot;)
public class HandlerImpl1 implements Handler 
{

public void handler() 
{
    System.out.println(&quot;this is handlerImpl1&quot;);

}

}

package com.mcg.java.tool.serviceloader.HandlerImpl;

import com.mcg.java.tool.serviceloader.Handler;
import com.mcg.java.tool.serviceloader.utils.ServiceAnnotation;

@ServiceAnnotation(name=&quot;handlerImpl2&quot;)
public class HandlerImpl2 implements Handler 
{

public void handler() 
{
    System.out.println(&quot;this is handlerImpl2&quot;);

}

}
</code></pre><p>//SPI配置文件（META-INF/services/com.mcg.java.tool.serviceloader.Handler）</p>
<pre><code>com.mcg.java.tool.serviceloader.HandlerImpl.DefaultHandlerImpl
com.mcg.java.tool.serviceloader.HandlerImpl.HandlerImpl1
com.mcg.java.tool.serviceloader.HandlerImpl.HandlerImpl2
</code></pre><p>//测试:</p>
<pre><code>package com.mcg.java.tool.serviceloader;

import com.mcg.java.tool.serviceloader.utils.ServicerLoaderUtils;

public class ServiceloaderTest 
{
@SuppressWarnings(&quot;unchecked&quot;)
public static void main(String[] args) throws Exception 
{
    Handler handler=(Handler) ServicerLoaderUtils.getService(&quot;default&quot;,Handler.class);
    handler.handler();
    Handler handler1=(Handler) ServicerLoaderUtils.getService(&quot;handlerImpl1&quot;,Handler.class);
    handler1.handler();
    Handler handler2=(Handler) ServicerLoaderUtils.getService(&quot;handlerImpl2&quot;,Handler.class);
    handler2.handler();
}

}
</code></pre><p>//结果：</p>
<pre><code>this is defaultHandler
this is handlerImpl1
this is handlerImpl2
</code></pre><p>在上面的showcase中，ServicerLoaderUtils和ServiceAnnotation是两个工具类，只要基于这两个工具类就可以实现基于名字来获取不同的服务，然后基于策略模式执行相应的服务。ServicerLoaderUtils的load方法中对接ServiceLoader来实现服务的加载。</p>
<p>ServiceLoader的源码分析</p>
<p>上面showcase中先根据ServiceLoader的load静态方法根据目标接口加载出一个ServiceLoader实例，然后可以遍历这个实例（实现了Iterable接口），获取到接口的所有实现类。</p>
<p>ServiceLoader有几个重要属性：</p>
<pre><code>//查找实现类的前级目录
private static final String PREFIX = &quot;META-INF/services/&quot;;

//要加载的接口
private Class&lt;S&gt; service;

// 
private ClassLoader loader;

// 缓存已经加载过的实现类，其中key为实现类的全名
private LinkedHashMap&lt;String,S&gt; providers = new LinkedHashMap&lt;&gt;();

//延迟加载器
private LazyIterator lookupIterator;
</code></pre><p>在上面调用load方法中，会创建ServiceLoader实例，会初始化的重要属性，此时还没有进行任何接口实现类的加载操作，属于延迟加载类型的。</p>
<p>在执行for循环的时候，由于ServiceLoader实现了Iterable接口，即实现了该接口的iterator()方法，实现内容如下：</p>
<pre><code>    public Iterator&lt;S&gt; iterator() {
    return new Iterator&lt;S&gt;() {

        Iterator&lt;Map.Entry&lt;String,S&gt;&gt; knownProviders
            = providers.entrySet().iterator();

        public boolean hasNext() {
            if (knownProviders.hasNext())
                return true;
            return lookupIterator.hasNext();
        }

        public S next() {
            if (knownProviders.hasNext())
                return knownProviders.next().getValue();
            return lookupIterator.next();
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

    };
}
</code></pre><p>其实for循环就是调用上述hasNext()和next()方法的过程。</p>
<p>第一次循环遍历会使用lookupIterator去查找，之后就缓存到providers中。LazyIterator会去加载类路径下/META-INF/services/接口全称 文件的url地址，使用如下代码来加载：</p>
<pre><code>String fullName = PREFIX + service.getName();
if (loader == null)
configs = ClassLoader.getSystemResources(fullName);
else
configs = loader.getResources(fullName);
</code></pre><p>文件加载并解析完成之后，得到一系列的接口实现类的完整类名，调用next()方法时才回去真正执行接口实现类的加载操作，并根据无参构造器创建出一个实例，存到providers中；</p>
<p>之后再次遍历ServiceLoader，就直接遍历providers中的数据</p>
<pre><code>S p = service.cast(c.newInstance());
providers.put(cn, p);
</code></pre><p>ServiceLoader缺点分析</p>
<p>虽然ServiceLoader也算是使用的延迟加载，但是基本只能通过遍历全部获取，也就是接口的实现类全部加载并实例化一遍。如果你并不想用某些实现类，它也被加载并实例化了，这就造成了浪费。</p>
<p>获取某个实现类的方式不够灵活，只能通过Iterator形式获取，不能根据某个参数来获取对应的实现类</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color4">SPI</a>
        		</li>
      		
		</ul>
	</div>

      
	<div class="article-category tagcloud">
		<i class="icon-book icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="/categories/日志/" class="article-tag-list-link color3">日志</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="/categories/dubbo/" class="article-tag-list-link color1">dubbo</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="/categories/Serviceloader/" class="article-tag-list-link color4">Serviceloader</a>
        		</li>
      		
		</ul>
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/2017/03/12/serviceloader/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-rpc" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/12/rpc/">RPC框架</a>
    </h1>
  

        
        <a href="/2017/03/12/rpc/" class="archive-article-date">
  	<time datetime="2017-03-12T12:39:14.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2017-03-12</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>分布式服务框架：用于实现服务复用，由一个RPC框架，注册中心，监控中心组成。大体会部署在应用层和数据层之间。其中RPC框架是最重要的部分，由服务端和客户端两部分组成，服务端暴露服务，会将服务信息注册到注册中心，客户端调用服务，会从注册中心获取服务信息，然后与服务端进行交互。实现一个高并发、高可用、高性能的的RPC框架涉及很多技术点。</p>
<p>下面是一个简单的RPC框架showcase，没有涉及注册中心，监控中心，服务端启动通过export方法暴露服务，客户端启动通过refer方法引用服务。</p>
<p>//暴露服务：</p>
<pre><code>package com.mcg.rpc.server;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Method;
import java.net.ServerSocket;
import java.net.Socket;

public class Provider
{
 public static void export(final Object instance, int port) throws Exception 
    {
    if(instance==null)
        throw new IllegalArgumentException(&quot;service is null&quot;);
    if (port &gt; 65535)
        throw new IllegalArgumentException(port + &quot;is invalid&quot;);
    ServerSocket serverSocket = new ServerSocket(port);
    for(;;) {  
        try { 
            final Socket socket = serverSocket.accept();  
            new Thread(new Runnable() {  
                public void run() {  
                    try {  
                        try {  
                            ObjectInputStream objectInputStream = new ObjectInputStream(socket.getInputStream());  
                            try {  
                                String methodName = objectInputStream.readUTF();  
                                Class&lt;?&gt;[] parameterTypes = (Class&lt;?&gt;[])objectInputStream.readObject();  
                                Object[] arguments = (Object[])objectInputStream.readObject();  
                                ObjectOutputStream objectOutputStream = new ObjectOutputStream(socket.getOutputStream());  
                                try {  
                                    Method method = instance.getClass().getMethod(methodName, parameterTypes);  
                                    Object result = method.invoke(instance, arguments);  
                                    objectOutputStream.writeObject(result);  
                                } catch (Throwable t) {  
                                    objectOutputStream.writeObject(t);  
                                } finally {  
                                    objectOutputStream.close();  
                                }  
                            } finally {  
                                objectInputStream.close();  
                            }  
                        } finally {  
                            socket.close();  
                        }  
                    } catch (Exception e) {  
                        e.printStackTrace();  
                    }  
                }  
            }).start();  
        } catch (Exception e) {  
            e.printStackTrace();  
        }  
    }  
} 
}
</code></pre><p>//引用服务：</p>
<pre><code>package com.mcg.rpc.client;

import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.net.Socket;

public class Consumer {

@SuppressWarnings(&quot;unchecked&quot;)
public static &lt;T&gt; T refer(final Class&lt;T&gt; serviceInterface,final String host,final int port)
{
    return (T)Proxy.newProxyInstance(serviceInterface.getClassLoader(),new Class&lt;?&gt;[]{serviceInterface}, new InvocationHandler()
    {  
        public Object invoke(Object proxy, Method method, Object[] arguments) throws Throwable {  
            Socket socket = new Socket(host, port);  
            try {  
                ObjectOutputStream output = new ObjectOutputStream(socket.getOutputStream());  
                try {  
                    output.writeUTF(method.getName());  
                    output.writeObject(method.getParameterTypes());  
                    output.writeObject(arguments);  
                    ObjectInputStream input = new ObjectInputStream(socket.getInputStream());  
                    try {  
                        Object result = input.readObject();  
                        if (result instanceof Throwable) {  
                            throw (Throwable) result;  
                        }  
                        return result;  
                    } finally {  
                        input.close();  
                    }  
                } finally {  
                    output.close();  
                }  
            } finally {  
                socket.close();  
            }  
        }  
    });  
}  
} 
</code></pre><p>//服务接口：</p>
<pre><code>package com.mcg.rpc.service;

public interface HelloService 
{
  void say(String name);
}
</code></pre><p>//服务实现：</p>
<pre><code>package com.mcg.rpc.service;

public class HelloServiceImpl implements HelloService 
 {
   public void say(String name) 
    {
    System.out.println(&quot;hello:&quot; + name);
    }
 } 
</code></pre><p>//测试:</p>
<pre><code>package com.mcg.rpc.server;

import com.mcg.rpc.service.HelloService;
import com.mcg.rpc.service.HelloServiceImpl;

public class ServerTest 
{
   private final static int PORT=1234;
   public static void main(String args []) throws Exception
     {
       HelloService instance=new HelloServiceImpl();
       Provider.export(instance, PORT);    
     }
}

package com.mcg.rpc.client;

import com.mcg.rpc.service.HelloService;

public class ClientTest
{
private final static int PORT=1234;
private final static String HOST=&quot;127.0.0.1&quot;;
public static void main(String args [])
 {
    HelloService helloService=Consumer.refer(HelloService.class, HOST, PORT);
    helloService.say(&quot;mcg&quot;);
 }
}
</code></pre><p>//结果：</p>
<pre><code>hello:mcg
</code></pre>
      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color4">RPC</a>
        		</li>
      		
		</ul>
	</div>

      
	<div class="article-category tagcloud">
		<i class="icon-book icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="/categories/日志/" class="article-tag-list-link color3">日志</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="/categories/分布式/" class="article-tag-list-link color4">分布式</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="/categories/分布式服务框架/" class="article-tag-list-link color3">分布式服务框架</a>
        		</li>
      		
		</ul>
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/2017/03/12/rpc/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-Annotation" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/19/Annotation/">Annotation</a>
    </h1>
  

        
        <a href="/2017/02/19/Annotation/" class="archive-article-date">
  	<time datetime="2017-02-19T13:23:35.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2017-02-19</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Annotation的注解定义通过关键字@interface表示。<br>定义注解格式：</p>
<pre><code>public @interface 注解名 {定义体}
</code></pre><p>注解参数的可支持数据类型：</p>
<pre><code>1.所有基本数据类型（int,float,boolean,byte,double,char,long,short)
2.String类型
3.Class类型
4.enum类型
5.Annotation类型
6.以上所有类型的数组
</code></pre><p>下面通过例子来分析注解：</p>
<pre><code>//注解类定义
package com.mcg.demo;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface AnnotationDemo 
 {
   String fun() default &quot;hello Annotation&quot;;
 }

//注解类使用demo
package com.mcg.demo;

@AnnotationDemo
public class AnnotationMain {

  public static void main(String[] args) {

    AnnotationDemo annotationDemo=AnnotationMain.class.getAnnotation(AnnotationDemo.class);
    String name=annotationDemo.fun();
    System.out.println(name);

}

}
//输出：
hello Annotation
</code></pre><p>观察上面使用例子以及输出结果，可以确定AnnotationDemo在编译过程中，编译器对其进行了语法糖处理。通过javap -verbose查看编译后的AnnotationDemo.class文件：</p>
<pre><code>public interface com.mcg.demo.AnnotationDemo extends java.lang.annotation.Annotation
SourceFile: &quot;AnnotationDemo.java&quot;
 RuntimeVisibleAnnotations:
  0: #14(#15=[e#16.#17])
  1: #18(#15=e#19.#20)
 minor version: 0
 major version: 49
flags: ACC_PUBLIC, ACC_INTERFACE, ACC_ABSTRACT, ACC_ANNOTATION
Constant pool:
#1 = Class              #2             //  com/mcg/demo/AnnotationDemo
#2 = Utf8               com/mcg/demo/AnnotationDemo
#3 = Class              #4             //  java/lang/Object
#4 = Utf8               java/lang/Object
#5 = Class              #6             //  java/lang/annotation/Annotation
#6 = Utf8               java/lang/annotation/Annotation
#7 = Utf8               fun
#8 = Utf8               ()Ljava/lang/String;
#9 = Utf8               AnnotationDefault
#10 = Utf8               hello Annotation
#11 = Utf8               SourceFile
#12 = Utf8               AnnotationDemo.java
#13 = Utf8               RuntimeVisibleAnnotations
#14 = Utf8               Ljava/lang/annotation/Target;
#15 = Utf8               value
#16 = Utf8               Ljava/lang/annotation/ElementType;
#17 = Utf8               TYPE
#18 = Utf8               Ljava/lang/annotation/Retention;
#19 = Utf8               Ljava/lang/annotation/RetentionPolicy;
#20 = Utf8               RUNTIME
{
 public abstract java.lang.String fun();
flags: ACC_PUBLIC, ACC_ABSTRACT
AnnotationDefault:
  default_value: s#10}
</code></pre><p>发现编译器将AnnotationDemo变成了接口，同时继承了java.lang.annotation.Annotation接口，Annotation接口是所有注解的共同基类接口。由于AnnotationDemo是接口，要调用fun()方法，需要创建出实现了AnnotationDemo的实例。观察使用例子语句：</p>
<pre><code>1.AnnotationDemo annotationDemo=AnnotationMain.class.getAnnotation(AnnotationDemo.class);
2.String name=annotationDemo.fun();
</code></pre><p>通过语句2确定语句1返回了一个实现了AnnotationDemo的实例。debug代码可以观察具体的调用堆栈，这里不具体讲解，过程中涉及到了一个重要的栈帧，是AnnotationParser的annotationForMap方法（如下），该方法的作用就是通过动态代理的机制返回一个实现了AnnotationDemo的代理类。所以语句1中annotationDemo就是这个代理类。</p>
<pre><code>//AnnotationParser
public static Annotation annotationForMap(Class&lt;? extends Annotation&gt; arg,
        Map&lt;String, Object&gt; arg0) {
    return (Annotation) Proxy.newProxyInstance(arg.getClassLoader(),
            new Class[]{arg}, new AnnotationInvocationHandler(arg, arg0));
}
</code></pre><p>AnnotationInvocationHandler类实现了InvocationHandler接口。</p>
<p>上面AnnotationDemo中设置了一些注解，这些注解是所谓的元注解，元注解的作用就是负责注解其他注解。Java5.0定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。Java5.0定义的元注解：</p>
<pre><code>1.@Target,2.@Retention,3.@Documented,4.@Inherited
</code></pre><p>@Target：</p>
<p>@Target说明了Annotation所修饰的对象范围：Annotation可被用于 packages、types（类、接口、枚举、Annotation类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数）。在Annotation类型的声明中使用了target可更加明晰其修饰的目标。</p>
<p>作用：用于描述注解的使用范围（即：被描述的注解可以用在什么地方）</p>
<p>取值(ElementType)有： </p>
<pre><code>1.CONSTRUCTOR:用于描述构造器
2.FIELD:用于描述域 
3.LOCAL_VARIABLE:用于描述局部变量 
4.METHOD:用于描述方法
5.PACKAGE:用于描述包
6.PARAMETER:用于描述参数   
7.TYPE:用于描述类、接口(包括注解类型) 或enum声明
</code></pre><p>@Retention：</p>
<p>@Retention定义了该Annotation被保留的时间长短：某些Annotation仅出现在源代码中，而被编译器丢弃；而另一些却被编译在class文件中；编译在class文件中的Annotation可能会被虚拟机忽略，而另一些在class被装载时将被读取（请注意并不影响class的执行，因为Annotation与class在使用上是被分离的）。使用这个meta-Annotation可以对 Annotation的“生命周期”限制。</p>
<p>作用：表示需要在什么级别保存该注释信息，用于描述注解的生命周期（即：被描述的注解在什么范围内有效）</p>
<p>取值（RetentionPoicy）有：</p>
<pre><code>1.SOURCE:在源文件中有效（即源文件保留）
2.CLASS:在class文件中有效（即class保留）
3.RUNTIME:在运行时有效（即运行时保留）
</code></pre><p>@Documented:</p>
<p>@Documented用于描述其它类型的annotation应该被作为被标注的程序成员的公共API，因此可以被例如javadoc此类的工具文档化。Documented是一个标记注解，没有成员。</p>
<p>@Inherited：</p>
<p>@Inherited 元注解是一个标记注解，@Inherited阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类。</p>
<p>　　　　
　　　　
　　　　</p>
<p>　    
　　　　
　　　
　　　　
　　　　
　　　　
　　　　</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color2">JAVA基础</a>
        		</li>
      		
		</ul>
	</div>

      
	<div class="article-category tagcloud">
		<i class="icon-book icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="/categories/日志/" class="article-tag-list-link color3">日志</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="/categories/JAVA基础/" class="article-tag-list-link color2">JAVA基础</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="/categories/注解(Annotation)/" class="article-tag-list-link color5">注解(Annotation)</a>
        		</li>
      		
		</ul>
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/2017/02/19/Annotation/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-Enum" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/12/Enum/">Enum</a>
    </h1>
  

        
        <a href="/2017/02/12/Enum/" class="archive-article-date">
  	<time datetime="2017-02-12T11:15:37.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2017-02-12</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Java的枚举定义通过关键字Enum表示。Enum定义类似如下：</p>
<pre><code>package com.mcg.demo;

public enum EnumDemo 
{
Demo1(&quot;demo1&quot;),Demo2(&quot;demo2&quot;),Demo3(&quot;demo3&quot;);

private String name;

EnumDemo(String name)
{
  this.name=name;

}
}
</code></pre><p>当我们使用EnumDemo类时，发现EnumDemo类默认给我们提供了values、valueOf方法</p>
<pre><code>EnumDemo.values();
EnumDemo.valueOf(&quot;demo1&quot;);
EnumDemo.valueOf(EnumDemo.class, &quot;demo1&quot;);
</code></pre><p>所以应该是编译器在编译源代码的时候，进行了特殊处理。需要分析编译后产生的class文件，</p>
<pre><code>public final class com.mcg.demo.EnumDemo extends java.lang.Enum&lt;com.mcg.demo.EnumDemo&gt; {
public static final com.mcg.demo.EnumDemo Demo1;
public static final com.mcg.demo.EnumDemo Demo2;
public static final com.mcg.demo.EnumDemo Demo3;
static {Demo1 = new com.mcg.demo.EnumDemo(&quot;Demo1&quot;,0);
Demo2 = new com.mcg.demo.EnumDemo(&quot;Demo2&quot;,1);
Demo3 = new com.mcg.demo.EnumDemo(&quot;Demo3&quot;,2);
$VALUES = (new com.mcg.demo.EnumDemo[] { Demo1, Demo2, Demo3 });}
private static final com.mcg.demo.EnumDemo $VALUES[];
private com.mcg.demo.EnumDemo(String s,int i) { super(s, i);}
public static com.mcg.demo.EnumDemo[] values() { return (com.mcg.demo.EnumDemo[])$VALUES.clone(); }
public static com.mcg.demo.EnumDemo valueOf(String name){ ... }
}
</code></pre><p>短短的几行代码，被编译器处理过之后竟然变得这么多，看来，enmu关键字是java提供给我们的一个语法糖，我们发现，编译器帮我们在编译后默认继承java.lang.Enum类，而不像其他的类一样默认继承Object类。且采用enum声明后，该类会被编译器加上final声明，故该类是无法继承的。Enum是java.lang包中的一个类，Enum类在JDK中是这样描述：(This is the common base class of all Java language enumeration types)Java语言中所有枚举类型的公共基类。</p>
<pre><code>public abstract class Enum&lt;E extends Enum&lt;E&gt;&gt; implements Comparable&lt;E&gt;, Serializable 
</code></pre><p>Enum类是一个抽象类，Enum实现了Serializable接口，可以序列化。 Enum实现了Comparable接口，可以进行比较，默认情况下，只有同类型的enum才进行比较（原因见后文），要实现不同类型的enum之间的比较，只能复写compareTo方法。</p>
<p>构造函数<br>Enum是一个抽象类，不能被实例化，但是他有构造函数，从前面我们反编译出来的代码中，我们也发现了Enum的构造函数，在Enum中只有一个保护类型的构造函数：</p>
<pre><code>rotected Enum(String name, int ordinal) {
this.name = name;
this.ordinal = ordinal;//代表顺序，从0开始；
}
</code></pre><p>其他方法</p>
<pre><code>public String toString() {
return name;
}

public final boolean equals(Object other) {
return this==other;
}

public final int hashCode() {
return super.hashCode();
}

public final int compareTo(E o) {
Enum other = (Enum)o;
Enum self = this;
if (self.getClass() != other.getClass() &amp;&amp; // optimization
    self.getDeclaringClass() != other.getDeclaringClass())
    throw new ClassCastException();
return self.ordinal - other.ordinal;
}

public final Class&lt;E&gt; getDeclaringClass() {
Class clazz = getClass();
Class zuper = clazz.getSuperclass();
return (zuper == Enum.class) ? clazz : zuper;
}

//valueOf(String name)调用该方法
public static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt; enumType,String name) {
T result = enumType.enumConstantDirectory().get(name);
if (result != null)
    return result;
if (name == null)
    throw new NullPointerException(&quot;Name is null&quot;);
throw new IllegalArgumentException(
    &quot;No enum constant &quot; + enumType.getCanonicalName() + &quot;.&quot; + name);
}
</code></pre>
      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color2">JAVA基础</a>
        		</li>
      		
		</ul>
	</div>

      
	<div class="article-category tagcloud">
		<i class="icon-book icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="/categories/日志/" class="article-tag-list-link color3">日志</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="/categories/JAVA基础/" class="article-tag-list-link color2">JAVA基础</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="/categories/枚举(Enum)/" class="article-tag-list-link color4">枚举(Enum)</a>
        		</li>
      		
		</ul>
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/2017/02/12/Enum/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-AbstractStringBuilder" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/29/AbstractStringBuilder/">AbstractStringBuilder</a>
    </h1>
  

        
        <a href="/2017/01/29/AbstractStringBuilder/" class="archive-article-date">
  	<time datetime="2017-01-29T02:13:23.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2017-01-29</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>String是不变字符串，而要实现可变字符串，可以通过继承AbstractStringBuilder类，AbstractStringBuilder是抽象类，实现了Appendable，CharSequence接口，具有append能力，同时也具备了返回字符串长度，返回特定位置字符，返回子串等能力，是StringBuilder和StringBuffer的父类。</p>
<p>类定义:</p>
<pre><code>abstract class AbstractStringBuilder implements Appendable, CharSequence
</code></pre><p>从类定义看，AbstractStringBuilder是包私有。</p>
<p>属性:</p>
<p>私有属性:</p>
<pre><code>char value[];（value数组保存字符串，不是final类型）

int count; 字符串的长度
</code></pre><p>方法:</p>
<p>AbstractStringBuilder提供了2个构造函数：</p>
<pre><code>//默认构造函数。
AbstractStringBuilder() {
}

//以capacity参数创建保存字符串的数组。
AbstractStringBuilder(int capacity) {
    value = new char[capacity];
}
</code></pre><p>append()函数系列</p>
<pre><code>public AbstractStringBuilder append(Object obj)
public AbstractStringBuilder append(String str)
public AbstractStringBuilder append(StringBuffer sb)
public AbstractStringBuilder append(CharSequence s)
public AbstractStringBuilder append(CharSequence s, int start, int end)
public AbstractStringBuilder append(char[] str)
public AbstractStringBuilder append(char str[], int offset, int len)
public AbstractStringBuilder append(boolean b)
public AbstractStringBuilder append(char c)
public AbstractStringBuilder append(int i)
public AbstractStringBuilder append(long l)
public AbstractStringBuilder append(float f)
public AbstractStringBuilder append(double d)
</code></pre><p>insert()函数系列</p>
<pre><code>public AbstractStringBuilder insert(int index, char[] str, int offset,int len)
public AbstractStringBuilder insert(int offset, Object obj)
public AbstractStringBuilder insert(int offset, String str)
public AbstractStringBuilder insert(int offset, char[] str)
public AbstractStringBuilder insert(int dstOffset, CharSequence s
public AbstractStringBuilder insert(int dstOffset, CharSequence s,int start, int end)
public AbstractStringBuilder insert(int offset, boolean b)
public AbstractStringBuilder insert(int offset, char c)
public AbstractStringBuilder insert(int offset, int i)
public AbstractStringBuilder insert(int offset, long l)
public AbstractStringBuilder insert(int offset, float f)
public AbstractStringBuilder insert(int offset, double d)
</code></pre><p>在append和insert等函数的时候，需要判断进行数组扩容，expandCapacity函数完成数组的扩容，具体处理逻辑如下：</p>
<pre><code>void expandCapacity(int minimumCapacity) {
    //原来数组的两倍+2(为什么这样设置，而不是2倍或其他)
    int newCapacity = value.length * 2 + 2;
    if (newCapacity - minimumCapacity &lt; 0)
    //如果newCapacity小于minimumCapacity，则将扩容大小设置为minimumCapacity
        newCapacity = minimumCapacity;
    if (newCapacity &lt; 0) {
        if (minimumCapacity &lt; 0) // overflow
            throw new OutOfMemoryError();
        newCapacity = Integer.MAX_VALUE;
    }
    //调用Arrays.copyOf将value复制到扩容后的数组
    value = Arrays.copyOf(value, newCapacity);
}

public void ensureCapacity(int minimumCapacity) //子类可以调用的方法实现扩容，在方法中调用ensureCapacityInternal
private void ensureCapacityInternal(int minimumCapacity) //ensureCapacityInternal调用ensureCapacityInternal
</code></pre><p>其他方法</p>
<pre><code>public int length() 返回字符串长度

public int capacity() 返回数组大小

public AbstractStringBuilder appendCodePoint(int codePoint)

public charAt(int index) 返回字符串中第（index+1）个字符

public AbstractStringBuilder deleteCharAt(int index)

public void setLength(int newLength) 设置字符串长度为newLength，如果newLength长度大于count，则以newLength为字符串长度，同时[count,newLengt-1]区间设置字符为&apos;/0&apos;;当newLength长度小于count，则字符串value[0,newLength-1]

public void trimToSize() 如果字符串小于数组长度，将数组长度设置为字符串

public int indexOf(String str) //返回str在字符串中的位置

public int lastIndexOf(String str) //返回str在字符串中最后的位置

public AbstractStringBuilder reverse()//反转

final char[] getValue() 返回数组

public String substring(int start, int end)

public CharSequence subSequence(int start, int end)

public AbstractStringBuilder replace(int start, int end, String str)
</code></pre><p>StringBuilder</p>
<pre><code>public final class StringBuilder extends AbstractStringBuilder implements java.io.Serializable, CharSequence
</code></pre><p>构造函数<br>    public StringBuilder() {<br>        super(16);//默认创建数组大小为16<br>    }<br>    public StringBuilder(int capacity)</p>
<pre><code>public StringBuilder(String str) {
    super(str.length() + 16);
    append(str);
}
public StringBuilder(CharSequence seq) {
    this(seq.length() + 16);
    append(seq);
}
</code></pre><p>其他方法覆盖了AbstractStringBuilder中的方法，然后在方法体内调用对应的AbstractStringBuilder方法。</p>
<p>StringBuffer</p>
<p>StringBuffer与StringBuilder类似，只是方法用synchronized进行了修饰。</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color2">JAVA基础</a>
        		</li>
      		
		</ul>
	</div>

      
	<div class="article-category tagcloud">
		<i class="icon-book icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="/categories/日志/" class="article-tag-list-link color3">日志</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="/categories/JAVA基础/" class="article-tag-list-link color2">JAVA基础</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="/categories/AbstractStringBuilder/" class="article-tag-list-link color2">AbstractStringBuilder</a>
        		</li>
      		
		</ul>
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/2017/01/29/AbstractStringBuilder/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-String" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/22/String/">String</a>
    </h1>
  

        
        <a href="/2017/01/22/String/" class="archive-article-date">
  	<time datetime="2017-01-22T06:21:45.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2017-01-22</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>String表示字符串，Java中所有字符串的字面值都是String类的实例。例如”hello world”,在定义之后就不能被改变。</p>
<p>类定义:</p>
<pre><code>public final class String
implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence
</code></pre><p>String类实现了Serializable，Comparable<t>,CharSequence接口。String类是final类，也就是说String类没有子类，为什么将String定义为final类型？我的理解是防止子类通过多态修改字符串。</t></p>
<p>CharSequence接口</p>
<p>CharSequence接口代表了一个只读的字符串，StringBuffer，StringBuilder也实现了该接口，该接口提供了4个方法：<br>    int length();返回字符串长度<br>    char charAt(int index);返回特定位置字符<br>    CharSequence subSequence(int start, int end);返回子串<br>    public String toString();</p>
<p>属性:</p>
<p>私有属性:</p>
<pre><code>private final char value[];（value数组保存字符串，定义为final类型）
</code></pre><p>方法:</p>
<p>String提供了10几种构造函数：</p>
<pre><code>//默认构造函数。
 public String() {
    this.value = new char[0];
}

//以String参数构造一个新分配的String 对象。
public String(String original) {
    this.value = original.value;
    this.hash = original.hash;
}

//以char数组为参数
public String(char value[]) {
    this.value = Arrays.copyOf(value, value.length);
}
</code></pre><p>在Java中，String实例中保存有一个char[]字符数组，char[]字符数组是以unicode码来存储的，String 和 char 为内存形式，byte是网络传输或存储的序列化形式。所以在很多传输和存储的过程中需要将byte[]数组和String进行相互转化。所以，String提供了一系列重载的构造方法来将一个字符数组转化成String，提到byte[]和String之间的相互转换就不得不关注编码问题。String(byte[] bytes, Charset charset)是指通过charset来解码指定的byte数组，将其解码成unicode的char[]数组，够造成新的String。</p>
<p>这里的bytes字节流是使用charset进行编码的，想要将他转换成unicode的char[]数组，而又保证不出现乱码，那就要指定其解码方式</p>
<pre><code>String(byte bytes[]) String(byte bytes[], int offset, int length)

String(byte bytes[], Charset charset)

String(byte bytes[], String charsetName)

String(byte bytes[], int offset, int length, Charset charset)
</code></pre><p>如果我们在使用byte[]构造String的时候，使用的是上面这四种构造方法(带有charsetName或者charset参数)的一种的话，那么就会使用StringCoding.decode方法进行解码，使用的解码的字符集就是我们指定的charsetName或者charset。 我们在使用byte[]构造String的时候，如果没有指明解码使用的字符集的话，那么StringCoding的decode方法首先调用系统的默认编码格式，如果没有指定编码格式则默认使用ISO-8859-1编码格式进行编码操作。主要体现代码如下： </p>
<pre><code>static char[] decode(byte[] ba, int off, int len) {
String csn = Charset.defaultCharset().name();
try {
        // use charset name decode() variant which provides caching.
        return decode(csn, ba, off, len);
 } catch (UnsupportedEncodingException x) {
        warnUnsupportedCharset(csn);
 }
 try {
        return decode(&quot;ISO-8859-1&quot;, ba, off, len);
 } catch (UnsupportedEncodingException x) {
        // If this code is hit during VM initialization, MessageUtils is
        // the only way we will be able to get any kind of error message.
        MessageUtils.err(&quot;ISO-8859-1 charset not available: &quot;+ x.toString());
        // If we can not find ISO-8859-1 (a required encoding) then things
        // are seriously wrong with the installation.
        System.exit(1);
        return null;
  }
}
</code></pre><p>getBytes</p>
<p>在创建String的时候，可以使用byte[]数组，将一个字节数组转换成字符串，同样，我们可以将一个字符串转换成字节数组，那么String提供了很多重载的getBytes方法。但是，值得注意的是，在使用这些方法的时候一定要注意编码问题。比如：</p>
<pre><code>String s = &quot;你好，世界！&quot;; 
byte[] bytes = s.getBytes();
</code></pre><p>这段代码在不同的平台上运行得到结果是不一样的。由于我们没有指定编码方式，所以在该方法对字符串进行编码的时候就会使用系统的默认编码方式，比如在中文操作系统中可能会使用GBK或者GB2312进行编码，在英文操作系统中有可能使用iso-8859-1进行编码。这样写出来的代码就和机器环境有很强的关联性了，所以，为了避免不必要的麻烦，我们要指定编码方式。如使用以下方式：</p>
<pre><code>String s = &quot;你好，世界！&quot;; 
byte[] bytes = s.getBytes(&quot;utf-8&quot;);
</code></pre><p>其他方法</p>
<pre><code>length() 返回字符串长度

isEmpty() 返回字符串是否为空

charAt(int index) 返回字符串中第（index+1）个字符

char[] toCharArray() 转化成字符数组

trim() 去掉两端空格

toUpperCase() 转化为大写

toLowerCase() 转化为小写

String concat(String str) //拼接字符串

String replace(char oldChar, char newChar) //将字符串中的oldChar字符换成newChar字符

//以上两个方法都使用了String(char[] value, boolean share)；

boolean matches(String regex) //判断字符串是否匹配给定的regex正则表达式

boolean contains(CharSequence s) //判断字符串是否包含字符序列s

String[] split(String regex, int limit) 按照字符regex将字符串分成limit份。

String[] split(String regex)

boolean equalsIgnoreCase(String anotherString)//比较大小

boolean contentEquals(StringBuffer sb)；

boolean contentEquals(CharSequence cs)

boolean endsWith(String suffix) //是否以suffix结尾

boolean startsWith(String prefix, int toffset)//是否以prefix开始

int compareTo(String anotherString)；

int compareToIgnoreCase(String str)；

boolean regionMatches(int toffset, String other, int ooffset,int len)  //局部匹配

boolean regionMatches(boolean ignoreCase, int toffset,String other, int ooffset, int len)   //局部匹配
</code></pre>
      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color2">JAVA基础</a>
        		</li>
      		
		</ul>
	</div>

      
	<div class="article-category tagcloud">
		<i class="icon-book icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="/categories/日志/" class="article-tag-list-link color3">日志</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="/categories/JAVA基础/" class="article-tag-list-link color2">JAVA基础</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="/categories/String/" class="article-tag-list-link color2">String</a>
        		</li>
      		
		</ul>
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/2017/01/22/String/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-Byte" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/13/Byte/">Byte</a>
    </h1>
  

        
        <a href="/2017/01/13/Byte/" class="archive-article-date">
  	<time datetime="2017-01-13T13:00:34.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2017-01-13</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Byte类是基本类型byte的包装类。</p>
<p>类定义:</p>
<pre><code>public final class Byte extends Number implements Comparable&lt;Byte&gt;
</code></pre><p>属性:</p>
<p>私有属性:</p>
<pre><code>private final byte value;（value属性就是Byte对象中真正保存int值的）
</code></pre><p>公共属性:</p>
<pre><code>public static final byte MIN_VALUE = -128;
public static final byte MAX_VALUE = 127;
public static final Class&lt;Byte&gt; TYPE = Class.getPrimitiveClass(&quot;byte&quot;);
public static final int SIZE = 8;
</code></pre><p>方法:</p>
<p>Integer提供了两个构造方法：</p>
<pre><code>//构造一个新分配的 Byte 对象，它表示指定的 byte 值。
public Byte(byte arg0) {
    this.value = arg0;
}

//构造一个新分配的 Byte 对象，它表示 String 参数所指示的 byte 值。
public Byte(String arg0) throws NumberFormatException {
    this.value = parseByte(arg0, 10);
}
</code></pre><p>Byte valueOf(byte arg)方法（effective java第一条准则）:</p>
<pre><code>//valueOf方法源码
public static Byte valueOf(byte arg) {
    return Byte.ByteCache.cache[arg + 128];
}
</code></pre><p>Byte类和Integer一样，调用valueOf方法时，会从缓存中取，不过不同的是Byte类调用valueOf取得都是缓存ByteCache中的值。</p>
<pre><code>    private static class ByteCache {
    static final Byte[] cache = new Byte[256];

    static {
        for (int arg = 0; arg &lt; cache.length; ++arg) {
            cache[arg] = new Byte((byte) (arg - 128));
        }

    }
}
</code></pre><p>作为Byte类的静态内部类，和Byte类一起加载，加载过程中会创建一个长度为256的数组，同时在静态内部块中初始化。</p>
<p>String转成Byte（byte）的方法:</p>
<pre><code>Byte decode(String arg)
Byte valueOf(String arg, int arg0)
byte parseByte(String arg)
byte parseByte(String arg, int arg0)
</code></pre><p>上述方法都是直接或间接的先将String转化为int类型，例如parseByte(String arg, int arg0)方法首先将String转化为int，然后判断该值是否在[-128，127]之间。</p>
<pre><code>public static byte parseByte(String arg, int arg0)
        throws NumberFormatException {
    int arg1 = Integer.parseInt(arg, arg0);
    if (arg1 &gt;= -128 &amp;&amp; arg1 &lt;= 127) {
        return (byte) arg1;
    } else {
        throw new NumberFormatException(&quot;Value out of range. Value:\&quot;&quot;
                + arg + &quot;\&quot; Radix:&quot; + arg0);
    }
}
</code></pre><p>int转成String的方法:</p>
<pre><code>String toString(byte arg) 
</code></pre><p>Byte的toString(byte arg)方法调用的是Integer的toString(byte arg，10)方法。</p>
<p>compareTo方法:</p>
<p>Byte类实现了Comparable<byte>接口，所以Byte对象可以和另外一个Byte对象进行比较。</byte></p>
<pre><code> public int compareTo(Byte arg0) {
    return compare(this.value, arg0.value);
}

public static int compare(byte arg, byte arg0) {
    return arg - arg0;
}
</code></pre><p>代码实现比较简单，就是拿出其中的byte类型的value进行比较。</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color2">JAVA基础</a>
        		</li>
      		
		</ul>
	</div>

      
	<div class="article-category tagcloud">
		<i class="icon-book icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="/categories/日志/" class="article-tag-list-link color3">日志</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="/categories/JAVA基础/" class="article-tag-list-link color2">JAVA基础</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="/categories/基本类型/" class="article-tag-list-link color5">基本类型</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="/categories/Byte/" class="article-tag-list-link color5">Byte</a>
        		</li>
      		
		</ul>
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/2017/01/13/Byte/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-Boolean" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/12/Boolean/">Boolean</a>
    </h1>
  

        
        <a href="/2017/01/12/Boolean/" class="archive-article-date">
  	<time datetime="2017-01-12T13:29:34.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2017-01-12</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Boolean类是基本类型boolean的包装类。</p>
<p>类定义:</p>
<pre><code>public final class Boolean implements Serializable, Comparable&lt;Boolean&gt;
</code></pre><p>类的定义与Integer类似，这里就不累赘了。</p>
<p>属性:</p>
<p>私有属性:</p>
<pre><code>private final boolean value;（value属性就是Boolean对象中真正保存boolean值的）
</code></pre><p>当我们使用new Boolean(True)创建一个Boolean对象的时候，就会用以下形式给value赋值</p>
<pre><code>public Boolean(boolean arg0) {
    this.value = arg0;
}
</code></pre><p>公共属性:</p>
<pre><code>//ture对应的Boolean静态常量。
public static final Boolean TRUE = new Boolean(true);
//false对应的Boolean静态常量
public static final Boolean FALSE = new Boolean(false);
public static final Class&lt;Boolean&gt; TYPE = Class
        .getPrimitiveClass(&quot;boolean&quot;);
</code></pre><p>方法:</p>
<p>Boolean提供了两个构造方法：</p>
<pre><code>//构造一个新分配的 Boolean 对象，它表示指定的 boolean 值。
public Boolean(boolean arg0) {
    this.value = arg0;
}


//构造一个新分配的 Boolean 对象，它表示 String 参数所指示的 boolean 值。
public Boolean(String arg0) {
    this(toBoolean(arg0));
}
</code></pre><p>Boolean valueOf(boolean i)方法:</p>
<pre><code>//valueOf方法源码
public static Boolean valueOf(boolean arg) {
    return arg ? TRUE : FALSE;
}
</code></pre><p>当参数是true时取常量TRUE，当参数是false时取常量FALSE。</p>
<p>String转成Boolean的方法:</p>
<pre><code>boolean getBoolean(String arg)
boolean toBoolean(String arg)
parseBoolean(String arg)
Boolean valueOf(String arg)
</code></pre><p>getBoolean:</p>
<pre><code>public static boolean getBoolean(String arg) {
    boolean arg0 = false;

    try {
        arg0 = toBoolean(System.getProperty(arg));
    } catch (IllegalArgumentException arg2) {
        ;
    } catch (NullPointerException arg3) {
        ;
    }

    return arg0;
}
</code></pre><p>确定具有指定名称的系统属性的Boolean值。 </p>
<p>toBoolean:</p>
<pre><code>private static boolean toBoolean(String arg) 
{
    return arg != null &amp;&amp; arg.equalsIgnoreCase(&quot;true&quot;);
}
</code></pre><p>将参数与字符串true进行比较</p>
<p>parseBoolean:</p>
<pre><code>public static boolean parseBoolean(String arg) {
    return toBoolean(arg);
}
</code></pre><p>该方法调用toBoolean，将String转化为boolean。</p>
<p>boolean转成String的方法:<br>    String toString(boolean arg)</p>
<p>直接看toString方法，toString方法的定义比较简单，就是把一个boolean类型转换成字符串类型。</p>
<pre><code>public static String toString(boolean arg) {
    return arg ? &quot;true&quot; : &quot;false&quot;;
}
</code></pre><p>compareTo方法:</p>
<pre><code>public int compareTo(Boolean arg0) {
    return compare(this.value, arg0.value);
}

public static int compare(boolean arg, boolean arg0) {
    return arg == arg0 ? 0 : (arg ? 1 : -1);
}
</code></pre><p>代码实现比较简单，就是拿出其中的boolean类型的value进行比较。</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color2">JAVA基础</a>
        		</li>
      		
		</ul>
	</div>

      
	<div class="article-category tagcloud">
		<i class="icon-book icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="/categories/日志/" class="article-tag-list-link color3">日志</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="/categories/JAVA基础/" class="article-tag-list-link color2">JAVA基础</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="/categories/基本类型/" class="article-tag-list-link color5">基本类型</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="/categories/Boolean/" class="article-tag-list-link color3">Boolean</a>
        		</li>
      		
		</ul>
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/2017/01/12/Boolean/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  


          </div>
        </div>
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 mcg
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		mathjax: false,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: true,
		root: "/",
		innerArchive: true,
		showTags: false
	}
</script>

<script>!function(t){function n(r){if(e[r])return e[r].exports;var o=e[r]={exports:{},id:r,loaded:!1};return t[r].call(o.exports,o,o.exports,n),o.loaded=!0,o.exports}var e={};return n.m=t,n.c=e,n.p="./",n(0)}([function(t,n,e){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,n){var e=/\/|index.html/g;return t.replace(e,"")===n.replace(e,"")}function i(){for(var t=document.querySelectorAll(".js-header-menu li a"),n=window.location.pathname,e=0,r=t.length;e<r;e++){var i=t[e];o(n,i.getAttribute("href"))&&(0,d.default)(i,"active")}}function u(t){for(var n=t.offsetLeft,e=t.offsetParent;null!==e;)n+=e.offsetLeft,e=e.offsetParent;return n}function f(t){for(var n=t.offsetTop,e=t.offsetParent;null!==e;)n+=e.offsetTop,e=e.offsetParent;return n}function c(t,n,e,r,o){var i=u(t),c=f(t)-n;if(c-e<=o){var a=t.$newDom;a||(a=t.cloneNode(!0),(0,h.default)(t,a),t.$newDom=a,a.style.position="fixed",a.style.top=(e||c)+"px",a.style.left=i+"px",a.style.zIndex=r||2,a.style.width="100%",a.style.color="#fff"),a.style.visibility="visible",t.style.visibility="hidden"}else{t.style.visibility="visible";var s=t.$newDom;s&&(s.style.visibility="hidden")}}function a(){var t=document.querySelector(".js-overlay"),n=document.querySelector(".js-header-menu");c(t,document.body.scrollTop,-63,2,0),c(n,document.body.scrollTop,1,3,0)}function s(){document.querySelector("#container").addEventListener("scroll",function(t){a()}),window.addEventListener("scroll",function(t){a()}),a()}function l(){x.default.versions.mobile&&window.screen.width<800&&(i(),s())}var p=e(71),d=r(p),v=e(72),y=(r(v),e(84)),h=r(y),b=e(69),x=r(b),m=e(75),g=r(m),w=e(70);l(),(0,w.addLoadEvent)(function(){g.default.init()}),t.exports={}},function(t,n){var e=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=e)},function(t,n){var e={}.hasOwnProperty;t.exports=function(t,n){return e.call(t,n)}},function(t,n,e){var r=e(49),o=e(15);t.exports=function(t){return r(o(t))}},function(t,n,e){t.exports=!e(8)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n,e){var r=e(6),o=e(12);t.exports=e(4)?function(t,n,e){return r.f(t,n,o(1,e))}:function(t,n,e){return t[n]=e,t}},function(t,n,e){var r=e(10),o=e(30),i=e(24),u=Object.defineProperty;n.f=e(4)?Object.defineProperty:function(t,n,e){if(r(t),n=i(n,!0),r(e),o)try{return u(t,n,e)}catch(t){}if("get"in e||"set"in e)throw TypeError("Accessors not supported!");return"value"in e&&(t[n]=e.value),t}},function(t,n,e){var r=e(22)("wks"),o=e(13),i=e(1).Symbol,u="function"==typeof i,f=t.exports=function(t){return r[t]||(r[t]=u&&i[t]||(u?i:o)("Symbol."+t))};f.store=r},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n,e){var r=e(35),o=e(16);t.exports=Object.keys||function(t){return r(t,o)}},function(t,n,e){var r=e(11);t.exports=function(t){if(!r(t))throw TypeError(t+" is not an object!");return t}},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n){var e=0,r=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++e+r).toString(36))}},function(t,n){var e=t.exports={version:"2.4.0"};"number"==typeof __e&&(__e=e)},function(t,n){t.exports=function(t){if(void 0==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,n){t.exports={}},function(t,n){t.exports=!0},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,e){var r=e(6).f,o=e(2),i=e(7)("toStringTag");t.exports=function(t,n,e){t&&!o(t=e?t:t.prototype,i)&&r(t,i,{configurable:!0,value:n})}},function(t,n,e){var r=e(22)("keys"),o=e(13);t.exports=function(t){return r[t]||(r[t]=o(t))}},function(t,n,e){var r=e(1),o="__core-js_shared__",i=r[o]||(r[o]={});t.exports=function(t){return i[t]||(i[t]={})}},function(t,n){var e=Math.ceil,r=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?r:e)(t)}},function(t,n,e){var r=e(11);t.exports=function(t,n){if(!r(t))return t;var e,o;if(n&&"function"==typeof(e=t.toString)&&!r(o=e.call(t)))return o;if("function"==typeof(e=t.valueOf)&&!r(o=e.call(t)))return o;if(!n&&"function"==typeof(e=t.toString)&&!r(o=e.call(t)))return o;throw TypeError("Can't convert object to primitive value")}},function(t,n,e){var r=e(1),o=e(14),i=e(18),u=e(26),f=e(6).f;t.exports=function(t){var n=o.Symbol||(o.Symbol=i?{}:r.Symbol||{});"_"==t.charAt(0)||t in n||f(n,t,{value:u.f(t)})}},function(t,n,e){n.f=e(7)},function(t,n,e){var r=e(1),o=e(14),i=e(46),u=e(5),f="prototype",c=function(t,n,e){var a,s,l,p=t&c.F,d=t&c.G,v=t&c.S,y=t&c.P,h=t&c.B,b=t&c.W,x=d?o:o[n]||(o[n]={}),m=x[f],g=d?r:v?r[n]:(r[n]||{})[f];d&&(e=n);for(a in e)s=!p&&g&&void 0!==g[a],s&&a in x||(l=s?g[a]:e[a],x[a]=d&&"function"!=typeof g[a]?e[a]:h&&s?i(l,r):b&&g[a]==l?function(t){var n=function(n,e,r){if(this instanceof t){switch(arguments.length){case 0:return new t;case 1:return new t(n);case 2:return new t(n,e)}return new t(n,e,r)}return t.apply(this,arguments)};return n[f]=t[f],n}(l):y&&"function"==typeof l?i(Function.call,l):l,y&&((x.virtual||(x.virtual={}))[a]=l,t&c.R&&m&&!m[a]&&u(m,a,l)))};c.F=1,c.G=2,c.S=4,c.P=8,c.B=16,c.W=32,c.U=64,c.R=128,t.exports=c},function(t,n){var e={}.toString;t.exports=function(t){return e.call(t).slice(8,-1)}},function(t,n,e){var r=e(11),o=e(1).document,i=r(o)&&r(o.createElement);t.exports=function(t){return i?o.createElement(t):{}}},function(t,n,e){t.exports=!e(4)&&!e(8)(function(){return 7!=Object.defineProperty(e(29)("div"),"a",{get:function(){return 7}}).a})},function(t,n,e){"use strict";var r=e(18),o=e(27),i=e(36),u=e(5),f=e(2),c=e(17),a=e(51),s=e(20),l=e(58),p=e(7)("iterator"),d=!([].keys&&"next"in[].keys()),v="@@iterator",y="keys",h="values",b=function(){return this};t.exports=function(t,n,e,x,m,g,w){a(e,n,x);var O,S,_,j=function(t){if(!d&&t in A)return A[t];switch(t){case y:return function(){return new e(this,t)};case h:return function(){return new e(this,t)}}return function(){return new e(this,t)}},P=n+" Iterator",E=m==h,M=!1,A=t.prototype,T=A[p]||A[v]||m&&A[m],L=T||j(m),N=m?E?j("entries"):L:void 0,C="Array"==n?A.entries||T:T;if(C&&(_=l(C.call(new t)),_!==Object.prototype&&(s(_,P,!0),r||f(_,p)||u(_,p,b))),E&&T&&T.name!==h&&(M=!0,L=function(){return T.call(this)}),r&&!w||!d&&!M&&A[p]||u(A,p,L),c[n]=L,c[P]=b,m)if(O={values:E?L:j(h),keys:g?L:j(y),entries:N},w)for(S in O)S in A||i(A,S,O[S]);else o(o.P+o.F*(d||M),n,O);return O}},function(t,n,e){var r=e(10),o=e(55),i=e(16),u=e(21)("IE_PROTO"),f=function(){},c="prototype",a=function(){var t,n=e(29)("iframe"),r=i.length,o="<",u=">";for(n.style.display="none",e(48).appendChild(n),n.src="javascript:",t=n.contentWindow.document,t.open(),t.write(o+"script"+u+"document.F=Object"+o+"/script"+u),t.close(),a=t.F;r--;)delete a[c][i[r]];return a()};t.exports=Object.create||function(t,n){var e;return null!==t?(f[c]=r(t),e=new f,f[c]=null,e[u]=t):e=a(),void 0===n?e:o(e,n)}},function(t,n,e){var r=e(35),o=e(16).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return r(t,o)}},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n,e){var r=e(2),o=e(3),i=e(45)(!1),u=e(21)("IE_PROTO");t.exports=function(t,n){var e,f=o(t),c=0,a=[];for(e in f)e!=u&&r(f,e)&&a.push(e);for(;n.length>c;)r(f,e=n[c++])&&(~i(a,e)||a.push(e));return a}},function(t,n,e){t.exports=e(5)},function(t,n,e){var r=e(15);t.exports=function(t){return Object(r(t))}},function(t,n,e){t.exports={default:e(41),__esModule:!0}},function(t,n,e){t.exports={default:e(42),__esModule:!0}},function(t,n,e){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}n.__esModule=!0;var o=e(39),i=r(o),u=e(38),f=r(u),c="function"==typeof f.default&&"symbol"==typeof i.default?function(t){return typeof t}:function(t){return t&&"function"==typeof f.default&&t.constructor===f.default&&t!==f.default.prototype?"symbol":typeof t};n.default="function"==typeof f.default&&"symbol"===c(i.default)?function(t){return"undefined"==typeof t?"undefined":c(t)}:function(t){return t&&"function"==typeof f.default&&t.constructor===f.default&&t!==f.default.prototype?"symbol":"undefined"==typeof t?"undefined":c(t)}},function(t,n,e){e(65),e(63),e(66),e(67),t.exports=e(14).Symbol},function(t,n,e){e(64),e(68),t.exports=e(26).f("iterator")},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n){t.exports=function(){}},function(t,n,e){var r=e(3),o=e(61),i=e(60);t.exports=function(t){return function(n,e,u){var f,c=r(n),a=o(c.length),s=i(u,a);if(t&&e!=e){for(;a>s;)if(f=c[s++],f!=f)return!0}else for(;a>s;s++)if((t||s in c)&&c[s]===e)return t||s||0;return!t&&-1}}},function(t,n,e){var r=e(43);t.exports=function(t,n,e){if(r(t),void 0===n)return t;switch(e){case 1:return function(e){return t.call(n,e)};case 2:return function(e,r){return t.call(n,e,r)};case 3:return function(e,r,o){return t.call(n,e,r,o)}}return function(){return t.apply(n,arguments)}}},function(t,n,e){var r=e(9),o=e(34),i=e(19);t.exports=function(t){var n=r(t),e=o.f;if(e)for(var u,f=e(t),c=i.f,a=0;f.length>a;)c.call(t,u=f[a++])&&n.push(u);return n}},function(t,n,e){t.exports=e(1).document&&document.documentElement},function(t,n,e){var r=e(28);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==r(t)?t.split(""):Object(t)}},function(t,n,e){var r=e(28);t.exports=Array.isArray||function(t){return"Array"==r(t)}},function(t,n,e){"use strict";var r=e(32),o=e(12),i=e(20),u={};e(5)(u,e(7)("iterator"),function(){return this}),t.exports=function(t,n,e){t.prototype=r(u,{next:o(1,e)}),i(t,n+" Iterator")}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n,e){var r=e(9),o=e(3);t.exports=function(t,n){for(var e,i=o(t),u=r(i),f=u.length,c=0;f>c;)if(i[e=u[c++]]===n)return e}},function(t,n,e){var r=e(13)("meta"),o=e(11),i=e(2),u=e(6).f,f=0,c=Object.isExtensible||function(){return!0},a=!e(8)(function(){return c(Object.preventExtensions({}))}),s=function(t){u(t,r,{value:{i:"O"+ ++f,w:{}}})},l=function(t,n){if(!o(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!i(t,r)){if(!c(t))return"F";if(!n)return"E";s(t)}return t[r].i},p=function(t,n){if(!i(t,r)){if(!c(t))return!0;if(!n)return!1;s(t)}return t[r].w},d=function(t){return a&&v.NEED&&c(t)&&!i(t,r)&&s(t),t},v=t.exports={KEY:r,NEED:!1,fastKey:l,getWeak:p,onFreeze:d}},function(t,n,e){var r=e(6),o=e(10),i=e(9);t.exports=e(4)?Object.defineProperties:function(t,n){o(t);for(var e,u=i(n),f=u.length,c=0;f>c;)r.f(t,e=u[c++],n[e]);return t}},function(t,n,e){var r=e(19),o=e(12),i=e(3),u=e(24),f=e(2),c=e(30),a=Object.getOwnPropertyDescriptor;n.f=e(4)?a:function(t,n){if(t=i(t),n=u(n,!0),c)try{return a(t,n)}catch(t){}if(f(t,n))return o(!r.f.call(t,n),t[n])}},function(t,n,e){var r=e(3),o=e(33).f,i={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],f=function(t){try{return o(t)}catch(t){return u.slice()}};t.exports.f=function(t){return u&&"[object Window]"==i.call(t)?f(t):o(r(t))}},function(t,n,e){var r=e(2),o=e(37),i=e(21)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=o(t),r(t,i)?t[i]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n,e){var r=e(23),o=e(15);t.exports=function(t){return function(n,e){var i,u,f=String(o(n)),c=r(e),a=f.length;return c<0||c>=a?t?"":void 0:(i=f.charCodeAt(c),i<55296||i>56319||c+1===a||(u=f.charCodeAt(c+1))<56320||u>57343?t?f.charAt(c):i:t?f.slice(c,c+2):(i-55296<<10)+(u-56320)+65536)}}},function(t,n,e){var r=e(23),o=Math.max,i=Math.min;t.exports=function(t,n){return t=r(t),t<0?o(t+n,0):i(t,n)}},function(t,n,e){var r=e(23),o=Math.min;t.exports=function(t){return t>0?o(r(t),9007199254740991):0}},function(t,n,e){"use strict";var r=e(44),o=e(52),i=e(17),u=e(3);t.exports=e(31)(Array,"Array",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,e=this._i++;return!t||e>=t.length?(this._t=void 0,o(1)):"keys"==n?o(0,e):"values"==n?o(0,t[e]):o(0,[e,t[e]])},"values"),i.Arguments=i.Array,r("keys"),r("values"),r("entries")},function(t,n){},function(t,n,e){"use strict";var r=e(59)(!0);e(31)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,e=this._i;return e>=n.length?{value:void 0,done:!0}:(t=r(n,e),this._i+=t.length,{value:t,done:!1})})},function(t,n,e){"use strict";var r=e(1),o=e(2),i=e(4),u=e(27),f=e(36),c=e(54).KEY,a=e(8),s=e(22),l=e(20),p=e(13),d=e(7),v=e(26),y=e(25),h=e(53),b=e(47),x=e(50),m=e(10),g=e(3),w=e(24),O=e(12),S=e(32),_=e(57),j=e(56),P=e(6),E=e(9),M=j.f,A=P.f,T=_.f,L=r.Symbol,N=r.JSON,C=N&&N.stringify,k="prototype",F=d("_hidden"),q=d("toPrimitive"),I={}.propertyIsEnumerable,B=s("symbol-registry"),D=s("symbols"),W=s("op-symbols"),H=Object[k],K="function"==typeof L,R=r.QObject,J=!R||!R[k]||!R[k].findChild,U=i&&a(function(){return 7!=S(A({},"a",{get:function(){return A(this,"a",{value:7}).a}})).a})?function(t,n,e){var r=M(H,n);r&&delete H[n],A(t,n,e),r&&t!==H&&A(H,n,r)}:A,G=function(t){var n=D[t]=S(L[k]);return n._k=t,n},$=K&&"symbol"==typeof L.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof L},z=function(t,n,e){return t===H&&z(W,n,e),m(t),n=w(n,!0),m(e),o(D,n)?(e.enumerable?(o(t,F)&&t[F][n]&&(t[F][n]=!1),e=S(e,{enumerable:O(0,!1)})):(o(t,F)||A(t,F,O(1,{})),t[F][n]=!0),U(t,n,e)):A(t,n,e)},Y=function(t,n){m(t);for(var e,r=b(n=g(n)),o=0,i=r.length;i>o;)z(t,e=r[o++],n[e]);return t},Q=function(t,n){return void 0===n?S(t):Y(S(t),n)},X=function(t){var n=I.call(this,t=w(t,!0));return!(this===H&&o(D,t)&&!o(W,t))&&(!(n||!o(this,t)||!o(D,t)||o(this,F)&&this[F][t])||n)},V=function(t,n){if(t=g(t),n=w(n,!0),t!==H||!o(D,n)||o(W,n)){var e=M(t,n);return!e||!o(D,n)||o(t,F)&&t[F][n]||(e.enumerable=!0),e}},Z=function(t){for(var n,e=T(g(t)),r=[],i=0;e.length>i;)o(D,n=e[i++])||n==F||n==c||r.push(n);return r},tt=function(t){for(var n,e=t===H,r=T(e?W:g(t)),i=[],u=0;r.length>u;)!o(D,n=r[u++])||e&&!o(H,n)||i.push(D[n]);return i};K||(L=function(){if(this instanceof L)throw TypeError("Symbol is not a constructor!");var t=p(arguments.length>0?arguments[0]:void 0),n=function(e){this===H&&n.call(W,e),o(this,F)&&o(this[F],t)&&(this[F][t]=!1),U(this,t,O(1,e))};return i&&J&&U(H,t,{configurable:!0,set:n}),G(t)},f(L[k],"toString",function(){return this._k}),j.f=V,P.f=z,e(33).f=_.f=Z,e(19).f=X,e(34).f=tt,i&&!e(18)&&f(H,"propertyIsEnumerable",X,!0),v.f=function(t){return G(d(t))}),u(u.G+u.W+u.F*!K,{Symbol:L});for(var nt="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),et=0;nt.length>et;)d(nt[et++]);for(var nt=E(d.store),et=0;nt.length>et;)y(nt[et++]);u(u.S+u.F*!K,"Symbol",{for:function(t){return o(B,t+="")?B[t]:B[t]=L(t)},keyFor:function(t){if($(t))return h(B,t);throw TypeError(t+" is not a symbol!")},useSetter:function(){J=!0},useSimple:function(){J=!1}}),u(u.S+u.F*!K,"Object",{create:Q,defineProperty:z,defineProperties:Y,getOwnPropertyDescriptor:V,getOwnPropertyNames:Z,getOwnPropertySymbols:tt}),N&&u(u.S+u.F*(!K||a(function(){var t=L();return"[null]"!=C([t])||"{}"!=C({a:t})||"{}"!=C(Object(t))})),"JSON",{stringify:function(t){if(void 0!==t&&!$(t)){for(var n,e,r=[t],o=1;arguments.length>o;)r.push(arguments[o++]);return n=r[1],"function"==typeof n&&(e=n),!e&&x(n)||(n=function(t,n){if(e&&(n=e.call(this,t,n)),!$(n))return n}),r[1]=n,C.apply(N,r)}}}),L[k][q]||e(5)(L[k],q,L[k].valueOf),l(L,"Symbol"),l(Math,"Math",!0),l(r.JSON,"JSON",!0)},function(t,n,e){e(25)("asyncIterator")},function(t,n,e){e(25)("observable")},function(t,n,e){e(62);for(var r=e(1),o=e(5),i=e(17),u=e(7)("toStringTag"),f=["NodeList","DOMTokenList","MediaList","StyleSheetList","CSSRuleList"],c=0;c<5;c++){var a=f[c],s=r[a],l=s&&s.prototype;l&&!l[u]&&o(l,u,a),i[a]=i.Array}},function(t,n){"use strict";var e={versions:function(){var t=window.navigator.userAgent;return{trident:t.indexOf("Trident")>-1,presto:t.indexOf("Presto")>-1,webKit:t.indexOf("AppleWebKit")>-1,gecko:t.indexOf("Gecko")>-1&&t.indexOf("KHTML")==-1,mobile:!!t.match(/AppleWebKit.*Mobile.*/),ios:!!t.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/),android:t.indexOf("Android")>-1||t.indexOf("Linux")>-1,iPhone:t.indexOf("iPhone")>-1||t.indexOf("Mac")>-1,iPad:t.indexOf("iPad")>-1,webApp:t.indexOf("Safari")==-1,weixin:t.indexOf("MicroMessenger")==-1}}()};t.exports=e},function(t,n,e){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}var o=e(40),i=r(o),u=function(){function t(t,n,e){return n||e?String.fromCharCode(n||e):o[t]||t}function n(t){return l[t]}var e=/&quot;|&lt;|&gt;|&amp;|&nbsp;|&apos;|&#(\d+);|&#(\d+)/g,r=/['<> "&]/g,o={"&quot;":'"',"&lt;":"<","&gt;":">","&amp;":"&","&nbsp;":" "},f=/\u00a0/g,c=/<br\s*\/?>/gi,a=/\r?\n/g,s=/\s/g,l={};for(var p in o)l[o[p]]=p;return o["&apos;"]="'",l["'"]="&#39;",{encode:function(t){return t?(""+t).replace(r,n).replace(a,"<br/>").replace(s,"&nbsp;"):""},decode:function(n){return n?(""+n).replace(c,"\n").replace(e,t).replace(f," "):""},encodeBase16:function(t){if(!t)return t;t+="";for(var n=[],e=0,r=t.length;r>e;e++)n.push(t.charCodeAt(e).toString(16).toUpperCase());return n.join("")},encodeBase16forJSON:function(t){if(!t)return t;t=t.replace(/[\u4E00-\u9FBF]/gi,function(t){return escape(t).replace("%u","\\u")});for(var n=[],e=0,r=t.length;r>e;e++)n.push(t.charCodeAt(e).toString(16).toUpperCase());return n.join("")},decodeBase16:function(t){if(!t)return t;t+="";for(var n=[],e=0,r=t.length;r>e;e+=2)n.push(String.fromCharCode("0x"+t.slice(e,e+2)));return n.join("")},encodeObject:function(t){if(t instanceof Array)for(var n=0,e=t.length;e>n;n++)t[n]=u.encodeObject(t[n]);else if("object"==("undefined"==typeof t?"undefined":(0,i.default)(t)))for(var r in t)t[r]=u.encodeObject(t[r]);else if("string"==typeof t)return u.encode(t);return t},loadScript:function(t){var n=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(n),n.setAttribute("src",t)},addLoadEvent:function(t){var n=window.onload;"function"!=typeof window.onload?window.onload=t:window.onload=function(){n(),t()}}}}();t.exports=u},function(t,n){function e(t,n){t.classList?t.classList.add(n):t.className+=" "+n}t.exports=e},function(t,n){function e(t,n){if(t.classList)t.classList.remove(n);else{var e=new RegExp("(^|\\b)"+n.split(" ").join("|")+"(\\b|$)","gi");t.className=t.className.replace(e," ")}}t.exports=e},,,function(t,n){"use strict";function e(){var t=document.querySelector("#page-nav");if(t&&!document.querySelector("#page-nav .extend.prev")&&(t.innerHTML='<a class="extend prev disabled" rel="prev">&laquo; Prev</a>'+t.innerHTML),t&&!document.querySelector("#page-nav .extend.next")&&(t.innerHTML=t.innerHTML+'<a class="extend next disabled" rel="next">Next &raquo;</a>'),yiliaConfig&&yiliaConfig.open_in_new){var n=document.querySelectorAll(".article-entry a:not(.article-more-a)");n.forEach(function(t){t.setAttribute("target","_blank")})}var e=document.querySelector("#js-aboutme");e&&0!==e.length&&(e.innerHTML=e.innerText)}t.exports={init:e}},,,,,,,,,function(t,n){function e(t,n){if("string"==typeof n)return t.insertAdjacentHTML("afterend",n);var e=t.nextSibling;return e?t.parentNode.insertBefore(n,e):t.parentNode.appendChild(n)}t.exports=e}])</script><script src="/./main.4a524f.js"></script><script>!function(){var e=function(e){var t=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(t),t.setAttribute("src",e)};e("/slider.885efe.js")}()</script>


    
<div class="tools-col" q-class="show:isShow,hide:isShow|isFalse" q-on="click:stop(e)">
  <div class="tools-nav header-menu">
    
    
      
      
      
    
      
    
      
      
      
    
    

    <ul style="width: 70%">
    
    
      
      <li style="width: 50%" q-on="click: openSlider(e, 'innerArchive')"><a href="javascript:void(0)" q-class="active:innerArchive">所有文章</a></li>
      
        
      
        
      
      <li style="width: 50%" q-on="click: openSlider(e, 'aboutme')"><a href="javascript:void(0)" q-class="active:aboutme">关于我</a></li>
      
        
    </ul>
  </div>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all" q-show="innerArchive">
        <div class="search-wrap">
          <input class="search-ipt" q-model="search" type="text" placeholder="find something…">
          <i class="icon-search icon" q-show="search|isEmptyStr"></i>
          <i class="icon-close icon" q-show="search|isNotEmptyStr" q-on="click:clearChose(e)"></i>
        </div>
        <div class="widget tagcloud search-tag">
          <p class="search-tag-wording">tag:</p>
          <label class="search-switch">
            <input type="checkbox" q-on="click:toggleTag(e)" q-attr="checked:showTags">
          </label>
          <ul class="article-tag-list" q-show="showTags">
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">杂谈</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">RPC</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">SPI</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">dubbo</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">JAVA基础</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">Comma</a>
              </li>
            
            <div class="clearfix"></div>
          </ul>
        </div>
        <ul class="search-ul">
          <p q-show="jsonFail" style="padding: 20px; font-size: 12px;">
            缺失模块。<br/>1、在博客根目录（注意不是yilia根目录）执行以下命令：<br/> npm i hexo-generator-json-content --save<br/><br/>
            2、在根目录_config.yml里添加配置：
<pre style="font-size: 12px;" q-show="jsonFail">
  jsonContent:
    meta: false
    pages: false
    posts:
      title: true
      date: true
      path: true
      text: true
      raw: false
      content: false
      slug: false
      updated: false
      comments: false
      link: false
      permalink: false
      excerpt: false
      categories: false
      tags: true
</pre>
          </p>
          <li class="search-li" q-repeat="items" q-show="isShow">
            <a q-attr="href:path|urlformat" class="search-title"><i class="icon-quo-left icon"></i><span q-text="title"></span></a>
            <p class="search-time">
              <i class="icon-calendar icon"></i>
              <span q-text="date|dateformat"></span>
            </p>
            <p class="search-tag">
              <i class="icon-price-tags icon"></i>
              <span q-repeat="tags" q-on="click:choseTag(e, name)" q-text="name|tagformat"></span>
            </p>
          </li>
        </ul>
    	</section>
    

    

    
    	<section class="tools-section tools-section-me" q-show="aboutme">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">我-&gt;想做一个有趣的人</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>